<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>vllmrt.net/spam</title>
    <link href="https://vllmrt.net/spam/atom.xml" rel="self" />
    <link href="https://vllmrt.net" />
    <id>https://vllmrt.net/spam/atom.xml</id>
    <author>
        <name>Robert Vollmert</name>
        
    </author>
    <updated>2019-12-13T00:00:00Z</updated>
    <entry>
    <title>Subverting Elm packaging for fun and profit</title>
    <link href="https://vllmrt.net/spam/subverting-elm.html" />
    <id>https://vllmrt.net/spam/subverting-elm.html</id>
    <published>2019-12-13T00:00:00Z</published>
    <updated>2019-12-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>December 13, 2019</time>
        
        
    </section>
    <p>An <a href="https://puzz.link/db">Elm application</a> I’m working on presents items with publication timestamps to users around the world. So far, I just printed a slightly mangled ISO-8601 UTC timestamp:</p>
<pre><code>formatTimestamp : String -&gt; String
formatTimestamp ts =
    ts
        |&gt; String.left (String.length &quot;2019-03-17T05:15&quot;)
        |&gt; String.replace &quot;T&quot; &quot; at &quot;</code></pre>
<p>That worked well enough for a start, but I felt it was time to solve this more properly and give my users localized timestamps.</p>
<p>This article is an account of my quest for a better, timezone aware variant of <code>formatTimestamp</code>. We’ll</p>
<ul>
<li>meet the ECMAScript Internationalization API</li>
<li>figure out how to write a simple native Elm module</li>
<li>build a binary package database using <code>printf(1)</code></li>
<li>to trick the Elm compiler into cooperating.</li>
</ul>
<aside>
What we’re doing here is most likely not the Elm team’s preferred approach. As such, best to keep this out of the official Elm community channels.
</aside>
<h1 id="the-internationalization-api">The Internationalization API</h1>
<p>The first thing we’ll need to do is to move from stringy timestamps to something more logical. Elm 0.19 talks Unix timestamps, with</p>
<pre><code>type Posix = Posix Int</code></pre>
<p>the number of milliseconds since the epoch. Instead of parsing the timestamps client-side using something like <a href="https://package.elm-lang.org/packages/rtfeldman/elm-iso8601-date-strings/latest/">rtfeldman/elm-iso8601-date-strings</a>, I opted to do the conversion in the PostgREST backend:</p>
<pre><code>          , published_at
+         , EXTRACT(EPOCH FROM published_at)*1000 AS published_at_posix</code></pre>
<p>So we’re now looking for a timezone and locale aware function <code>formatTimestamp : Posix -&gt; String</code>. It turns out that browsers have a rather neat interface for this and related topics in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">ECMAScript Internationalization API</a>. Here’s a way to do what I want, given a <code>Posix</code> value:</p>
<pre><code>function formatTimestamp(posix) {
	var dateTimeFormat = new Intl.DateTimeFormat(undefined, {
		year: &#39;numeric&#39;,
		month: &#39;numeric&#39;,
		day: &#39;numeric&#39;,
		hour: &#39;numeric&#39;,
		minute: &#39;numeric&#39;
	});
	return dateTimeFormat.format(posix);
}</code></pre>
<p>The <code>undefined</code> first argument to the constructor means to use the user locale. The unspecified timezone in the second options argument means to use the user’s local timezone (I think). Together, this formats Dec 11 15:00:00 UTC 2019 to a pleasing</p>
<blockquote>
<p>11/12/2019, 16:00</p>
</blockquote>
<p>in my <code>en-GB</code> locale in the <code>Europe/Berlin</code> timezone.</p>
<aside>
<p>If my locale were, say, <code>en-US</code> or <code>th-u-ca-buddhist</code>, this would show as</p>
<blockquote>
<p>12/11/2019, 4:00 PM</p>
</blockquote>
<p>or</p>
<blockquote>
<p>11/12/2562 15:00</p>
</blockquote>
<p>respectively.</p>
<p>To figure out your local settings, enter the following in your browser console:</p>
<pre><code>new Intl.DateTimeFormat().resolvedOptions()</code></pre>
</aside>
<p>Doing the same in Elm 0.19 turns out to be tricky, however. The time library situation is a bit of a mess, with a very barebones core library <a href="https://package.elm-lang.org/packages/elm/time/1.0.0/">elm/time</a> that speaks Unix timestamps, and a variety of other date and time related packages, none of which appear to do the job.</p>
<p>And after all, we have a simple, mostly pure Javascript solution available, so why not just use that?</p>
<aside>
There’s an 0.18 package <a href="https://github.com/vanwagonet/elm-intl">vanwagonet/elm-intl</a> wrapping <code>Intl</code>, but attempts to get that functionality into 0.19 were <a href="https://discourse.elm-lang.org/t/bindings-for-intl/1264">stalled</a>.
</aside>
<h1 id="calling-native-code">Calling native code</h1>
<p>The documented approach to interacting with Javascript code from Elm is using <a href="https://guide.elm-lang.org/interop/ports.html">ports</a>, which would effectively turn a simple function call into an asynchronous RPC invocation with a ton of scaffolding. That didn’t appear to be an acceptable solution, so I thought I’d apply my <a href="guix-elm-2.html">recent insight</a> into the <code>elm</code> tooling to figure out how to use the Javascript API from within Elm. It seemed like a fun challenge, too!</p>
<h2 id="a-native-module">A native module</h2>
<p>By following along what <code>vanwagonet/elm-intl</code> and <code>elm/time</code> do for their Javascript interop, I came up with a native module <code>Elm.Kernel.DateTime</code> implemented in the file <code>src/Elm/Kernel/DateTime.js</code></p>
<pre><code>/*

*/

function _DateTime_localNumericDateTime() {
        return new Intl.DateTimeFormat(undefined, {
                year: &#39;numeric&#39;,
                month: &#39;numeric&#39;,
                day: &#39;numeric&#39;,
                hour: &#39;numeric&#39;,
                minute: &#39;numeric&#39;
        });
}

var _DateTime_format = F2(function (dateTimeFormat, value) {
	return dateTimeFormat.format(value);
});</code></pre>
<p>together with an Elm wrapper module <code>DateTime</code> implemented in <code>src/DateTime.elm</code>:</p>
<pre><code>module DateTime exposing ( DateTimeFormat, localNumericDateTime, format )

import Elm.Kernel.DateTime
import Maybe exposing (Maybe)
import Time exposing (Posix)

type DateTimeFormat
    = DateTimeFormat

localNumericDateTime : DateTimeFormat
localNumericDateTime =
    Elm.Kernel.DateTime.localNumericDateTime ()

format : DateTimeFormat -&gt; Posix -&gt; String
format dateTimeFormat posix =
    Elm.Kernel.DateTime.format dateTimeFormat (Time.posixToMillis posix)</code></pre>
<p>Walking through the Javascript file, it starts with an empty header comment listing Elm imports (we don’t have any). Then, we declare the function</p>
<pre><code>Elm.Kernel.DateTime.localNumericDateTime</code></pre>
<p>as <code>_DateTime_localNumericDateTime</code>. This is called from Elm with a unit argument. Finally we declare the two-argument function <code>_DateTime_format</code> in curried form using the helper <code>F2</code>.</p>
<h2 id="compiling-the-module">Compiling the module</h2>
<p>Setting things up naïvely with the following <code>elm.json</code></p>
<pre><code>{
    &quot;type&quot;: &quot;package&quot;,
    &quot;name&quot;: &quot;robx/elm-datetime&quot;,
    &quot;summary&quot;: &quot;Format local dates and times via JavaScript&quot;,
    &quot;license&quot;: &quot;BSD-3-Clause&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;exposed-modules&quot;: [
        &quot;DateTime&quot;
    ],
    &quot;elm-version&quot;: &quot;0.19.0 &lt;= v &lt; 0.20.0&quot;,
    &quot;dependencies&quot;: {
        &quot;elm/core&quot;: &quot;1.0.0 &lt;= v &lt; 2.0.0&quot;,
        &quot;elm/time&quot;: &quot;1.0.0 &lt;= v &lt; 2.0.0&quot;
    },
    &quot;test-dependencies&quot;: {}
}</code></pre>
<p>we get an error in <code>elm make</code>:</p>
<pre><code>$ elm make
-- BAD MODULE NAME -------------------------------------------- src/DateTime.elm

Your DateTime module is trying to import:

    Elm.Kernel.DateTime

But names like that are reserved for internal use. Switch to a name outside of
the Elm/Kernel/ namespace.
</code></pre>
<p>Bad robx, no cookie. Instead of moving the module out of the Elm namespace, let’s move our package in.</p>
<pre><code>-    &quot;name&quot;: &quot;robx/elm-datetime&quot;,
+    &quot;name&quot;: &quot;elm/my-elm-datetime&quot;,</code></pre>
<p>Now <code>elm make</code> is happy:</p>
<pre><code>$ elm make
Success! Compiled 1 module.</code></pre>
<aside>
Here, we should also call <code>elm make --docs=docs.json</code> to check that it’s happy with the state of documentation. Otherwise, compiling an app using this package will fail with an obscure error message. Elm tooling ensures that published package dependencies don’t fail to compile, but we’ll have to bypass some of that later.
</aside>
<h2 id="a-little-demo-app">A little demo app</h2>
<p>To test our function and give us something concrete to try to make work, let’s build a small demo app that merely ticks a clock:</p>
<pre class="scroll"><code>module Demo exposing (main)

import Browser
import DateTime
import Html
import Time


main : Program () Model Msg
main =
    Browser.document
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


type alias Model =
    { time : Maybe Time.Posix
    }


type Msg
    = Tick Time.Posix

init : () -&gt; ( Model, Cmd Msg )
init flags =
    ( { time = Nothing }
    , Cmd.none
    )

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        Tick posix -&gt;
            ( { model | time = Just posix }, Cmd.none )

view : Model -&gt; Browser.Document Msg
view model =
    let
        format = DateTime.format DateTime.localNumericDateTime
    in
    { title = &quot;puzzle&quot;
    , body =
        case model.time of
            Just posix -&gt;
               [ Html.div [] [ Html.text &lt;| String.fromInt &lt;| Time.posixToMillis &lt;| posix ]
               , Html.div [] [ Html.text &lt;| format posix ]
               ]
            _ -&gt; [ Html.div [] [ Html.text &quot;...&quot; ] ]
    }


subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Time.every 1000 Tick</code></pre>
<p>It tracks the current time in the model by subscribing to <code>Time.every</code>, and displays that next to the formatted version.</p>
<p>But how to build this? Again, we can assemble a naïve <code>elm.json</code>:</p>
<pre><code>{
    &quot;type&quot;: &quot;application&quot;,
    &quot;source-directories&quot;: [
        &quot;src&quot;
    ],
    &quot;elm-version&quot;: &quot;0.19.0&quot;,
    &quot;dependencies&quot;: {
        &quot;direct&quot;: {
            &quot;elm/browser&quot;: &quot;1.0.1&quot;,
            &quot;elm/core&quot;: &quot;1.0.2&quot;,
            &quot;elm/html&quot;: &quot;1.0.0&quot;,
            &quot;elm/time&quot;: &quot;1.0.0&quot;,
            &quot;elm/my-elm-datetime&quot;: &quot;1.1.0&quot;
        },
        &quot;indirect&quot;: {
            &quot;elm/json&quot;: &quot;1.1.3&quot;,
            &quot;elm/url&quot;: &quot;1.0.0&quot;,
            &quot;elm/virtual-dom&quot;: &quot;1.0.2&quot;
        }
    },
    &quot;test-dependencies&quot;: {
        &quot;direct&quot;: {},
        &quot;indirect&quot;: {}
    }
}</code></pre>
<p>Naturally, this can’t work because <code>elm/my-elm-datetime</code> doesn’t exist to the <code>elm</code> tool:</p>
<pre><code>$ elm make src/Demo.elm
-- CORRUPT CACHE ---------------------------------------------------------------

I ran into an unknown package while exploring dependencies:

    elm/my-elm-datetime

[...]</code></pre>
<h2 id="how-to-get-the-module-into-the-app">How to get the module into the app?</h2>
<p>Of course, we can’t publish to the Elm package database under a name we don’t own, which is where we get to the fun part: The same approach I took when <a href="guix-elm-2.html">building Elm apps on Guix</a> can help here. In fact, if we were just building on Guix, we could pull in my pretend-elm package quite easily without any extra work. But I’m not regularly developing using Guix, so I wanted to find a shell-based solution to do the necessary environment tweaks to get Elm to play along. What we’ll do is:</p>
<ol type="1">
<li>fetch dependency archives and unpack them in our own elm home directory. I went with <code>./elm-stuff/home</code>, which means unpacking e.g. our <code>elm-datetime</code> package to <code>./elm-stuff/home/.elm/0.19.1/packages/elm/my-elm-datetime</code>, and accordingly for all dependencies in elm.json.</li>
<li>generate an elm registry, by using <code>printf(1)</code> to generate binary data</li>
<li>call <code>HOME=./elm-stuff/home HTTP_PROXY=. elm make</code> to build.</li>
</ol>
<p>I collected and wrapped up the various shell snippets involved in this as a bash script, available at <a href="https://github.com/robx/shelm">robx/shelm</a>. Let’s have a look at some of the core parts:</p>
<p>For regular Elm packages, step 1 may be achieved with <a href="https://stedolan.github.io/jq/"><code>jq</code></a>, <code>curl</code> and <code>tar</code>:</p>
<pre><code>jq -r &#39;.dependencies.direct+.dependencies.indirect
	| to_entries[]
	| [.key, .value]
	| @tsv&#39; | while read package version
do {
	unpack=$(mktemp -d)
	(cd $unpack &amp;&amp; curl -L https://github.com/&quot;$package&quot;/archive/&quot;$version&quot;.tar.gz | tar -xz)
	dest=&quot;$ELM_HOME&quot;/0.19.1/packages/&quot;$package&quot;
	mkdir -p &quot;$dest&quot;
	mv &quot;$unpack&quot;/* &quot;$dest&quot;
	rmdir &quot;$dest&quot;
done</code></pre>
<p>We collect all dependencies from <code>elm.json</code>, and then just need to do a little bit of careful work to move them to the right place.</p>
<p>It turns out that this code also works just fine for our unpublished package <code>elm/my-elm-datetime</code>. The only thing we need to do is redirect to the real GitHub project <code>robx/elm-datetime</code>. I chose to encode this information in an extra <code>elm.json</code> field:</p>
<pre><code>&quot;dependencies&quot;: {
    &quot;direct&quot;: {
        ...
        &quot;elm/my-elm-datetime&quot;: &quot;1.0.0&quot;
    },
    &quot;locations&quot;: {
        &quot;elm/my-elm-datetime&quot;: {
            &quot;method&quot;: &quot;github&quot;,
            &quot;name&quot;: &quot;robx/elm-datetime&quot;
        }
    }
}</code></pre>
<p>A more compact format like <code>"elm/my-elm-datetime": "robx/elm-datetime"</code> worked initially; the present form is a result of overengineering the packaging script. We might tweak our unpacking fragment above to support this as follows:</p>
<pre><code>location=$(jq &#39;.dependencies.locations.&quot;&#39;&quot;$package&quot;&#39;.name // &quot;&#39;&quot;$package&quot;&#39;&quot; &lt; elm.json)
(cd $unpack &amp;&amp; curl -L https://github.com/&quot;$location&quot;/archive/&quot;$version&quot;.tar.gz | tar -xz)</code></pre>
<p>For step 2, we list the packages and versions that we’ve just “installed” into the package cache, and write them to Elm’s binary package registry format. We can use <code>printf(1)</code> for this. E.g., integers are encoded as 8 big-endian bytes:</p>
<pre><code># Haskell binary encoding of integers as 8 bytes big-endian
encode_int64() {
        hex=$(printf &quot;%016x&quot; &quot;$1&quot;)
        printf &quot;\\x${hex:0:2}\\x${hex:2:2}\\x${hex:4:2}\\x${hex:6:2}&quot;
        printf &quot;\\x${hex:8:2}\\x${hex:10:2}\\x${hex:12:2}\\x${hex:14:2}&quot;
}</code></pre>
<p>See the <a href="guix-elm-2.html">guix discussion</a> for more details.</p>
<p>After fixing various bugs, this works!</p>
<pre class="scroll"><code>$ (cd elm-stuff/home/.elm/0.19.1/packages &amp;&amp; ls -d */*/*)
elm/browser/1.0.1		elm/my-elm-datetime/1.0.0
elm/core/1.0.2			elm/time/1.0.0
elm/html/1.0.0			elm/url/1.0.0
elm/json/1.1.3			elm/virtual-dom/1.0.2
$ hexdump -C elm-stuff/home/.elm/0.19.1/packages/registry.dat
00000000  00 00 00 00 00 00 00 08  00 00 00 00 00 00 00 08  |................|
00000010  03 65 6c 6d 07 62 72 6f  77 73 65 72 01 00 01 00  |.elm.browser....|
00000020  00 00 00 00 00 00 00 03  65 6c 6d 04 63 6f 72 65  |........elm.core|
00000030  01 00 02 00 00 00 00 00  00 00 00 03 65 6c 6d 04  |............elm.|
00000040  68 74 6d 6c 01 00 00 00  00 00 00 00 00 00 00 03  |html............|
00000050  65 6c 6d 04 6a 73 6f 6e  01 01 03 00 00 00 00 00  |elm.json........|
00000060  00 00 00 03 65 6c 6d 0f  6d 79 2d 65 6c 6d 2d 64  |....elm.my-elm-d|
00000070  61 74 65 74 69 6d 65 01  01 00 00 00 00 00 00 00  |atetime.........|
00000080  00 00 03 65 6c 6d 04 74  69 6d 65 01 00 00 00 00  |...elm.time.....|
00000090  00 00 00 00 00 00 03 65  6c 6d 03 75 72 6c 01 00  |.......elm.url..|
000000a0  00 00 00 00 00 00 00 00  00 03 65 6c 6d 0b 76 69  |..........elm.vi|
000000b0  72 74 75 61 6c 2d 64 6f  6d 01 00 02 00 00 00 00  |rtual-dom.......|
000000c0  00 00 00 00                                       |....|
000000c4
$ HOME=$(pwd)/elm-stuff/home HTTP_PROXY=. elm make --output=demo.js src/Demo.elm
Dependencies loaded from local cache.
Dependencies ready!
Success! Compiled 1 module.</code></pre>
<p>Here’s our app in action.</p>
<figure>
<iframe title="elm-datetime demo, v1" src="/misc/elm-datetime-demo/v1.html" width="200" height="75">
</iframe>
<figcaption>
elm-datetime demo, v1
</figcaption>
</figure>
<h1 id="making-things-right">Making things right</h1>
<p>We might stop here, but there’s still an issue with our native <code>DateTime</code> module. While</p>
<pre><code>format : DateTimeFormat -&gt; Posix -&gt; String</code></pre>
<p>itself is a pure function,</p>
<pre><code>localNumericDateTime : DateTimeFormat</code></pre>
<p>is lying when it pretends to be: Calling <code>Intl.DateTime(locale, options)</code> without fully resolved options as we do depends on the environment, and might change between calls, e.g. if the timezone changes.</p>
<p>To model this correctly, we should change it to have a <code>Task</code> type:</p>
<pre><code>localNumericDateTime : Task x DateTimeFormat</code></pre>
<p>Modelling things on <a href="https://package.elm-lang.org/packages/elm/time/latest/Time#here"><code>Time.here</code></a>, we change the Javascript module as follows:</p>
<pre><code>--- a/src/Elm/Kernel/DateTime.js
+++ b/src/Elm/Kernel/DateTime.js
@@ -1,14 +1,21 @@
 /*

+import Elm.Kernel.Scheduler exposing (binding, succeed)
+
 */

 function _DateTime_localNumericDateTime() {
-       return new Intl.DateTimeFormat(undefined, {
-               year: &#39;numeric&#39;,
-               month: &#39;numeric&#39;,
-               day: &#39;numeric&#39;,
-               hour: &#39;numeric&#39;,
-               minute: &#39;numeric&#39;
+       return __Scheduler_binding(function(callback)
+       {
+               callback(__Scheduler_succeed(
+                       new Intl.DateTimeFormat(undefined, {
+                               year: &#39;numeric&#39;,
+                               month: &#39;numeric&#39;,
+                               day: &#39;numeric&#39;,
+                               hour: &#39;numeric&#39;,
+                               minute: &#39;numeric&#39;
+                       })
+               ));
        });
 }</code></pre>
<p><code>Elm.Kernel.Scheduler</code> is the native module behind <a href="https://package.elm-lang.org/packages/elm/core/1.0.4/Task"><code>Task</code></a>. The Elm-side diff is trivial:</p>
<pre><code>--- a/src/DateTime.elm
+++ b/src/DateTime.elm
@@ -22,6 +22,7 @@ This module binds to

 import Elm.Kernel.DateTime
 import Maybe exposing (Maybe)
+import Task exposing (Task)
 import Time exposing (Posix)


@@ -33,7 +34,7 @@ type DateTimeFormat

 {-| Create a DateTimeFormat using user locale and timezone.
 -}
-localNumericDateTime : DateTimeFormat
+localNumericDateTime : Task x DateTimeFormat
 localNumericDateTime =
     Elm.Kernel.DateTime.localNumericDateTime ()
</code></pre>
<p>And let’s bump the package version:</p>
<pre><code>--- a/elm.json
+++ b/elm.json
@@ -3,7 +3,7 @@
     &quot;name&quot;: &quot;elm/my-elm-datetime&quot;,
     &quot;summary&quot;: &quot;Format local dates and times via JavaScript&quot;,
     &quot;license&quot;: &quot;BSD-3-Clause&quot;,
-    &quot;version&quot;: &quot;1.0.0&quot;,
+    &quot;version&quot;: &quot;1.1.0&quot;,
     &quot;exposed-modules&quot;: [
         &quot;DateTime&quot;
     ],</code></pre>
<p>Getting this into our demo involves performing this task to obtain our formatter at application startup, and keeping it around in the model:</p>
<pre class="scroll"><code>+++ b/demo/elm.json
@@ -10,7 +10,7 @@
             &quot;elm/core&quot;: &quot;1.0.2&quot;,
             &quot;elm/html&quot;: &quot;1.0.0&quot;,
             &quot;elm/time&quot;: &quot;1.0.0&quot;,
-            &quot;elm/my-elm-datetime&quot;: &quot;1.0.0&quot;
+            &quot;elm/my-elm-datetime&quot;: &quot;1.1.0&quot;
         },
         &quot;indirect&quot;: {
             &quot;elm/json&quot;: &quot;1.1.3&quot;,
diff --git a/demo/src/Demo.elm b/demo/src/Demo.elm
index fd85793..776b913 100644
--- a/demo/src/Demo.elm
+++ b/demo/src/Demo.elm
@@ -3,6 +3,7 @@ module Demo exposing (main)
 import Browser
 import DateTime
 import Html
+import Task
 import Time


@@ -18,17 +19,19 @@ main =

 type alias Model =
     { time : Maybe Time.Posix
+    , format : Maybe DateTime.DateTimeFormat
     }


 type Msg
     = Tick Time.Posix
+    | NewFormat DateTime.DateTimeFormat


 init : () -&gt; ( Model, Cmd Msg )
 init flags =
-    ( { time = Nothing }
-    , Cmd.none
+    ( { time = Nothing, format = Nothing }
+    , Task.perform NewFormat DateTime.localNumericDateTime
     )


@@ -38,17 +41,20 @@ update msg model =
         Tick posix -&gt;
             ( { model | time = Just posix }, Cmd.none )

+        NewFormat fmt -&gt;
+            ( { model | format = Just fmt }, Cmd.none )
+

 view : Model -&gt; Browser.Document Msg
 view model =
-    let
-        format =
-            DateTime.format DateTime.localNumericDateTime
-    in
     { title = &quot;puzzle&quot;
     , body =
-        case model.time of
-            Just posix -&gt;
+        case ( model.time, model.format ) of
+            ( Just posix, Just fmt ) -&gt;
+                let
+                    format =
+                        DateTime.format fmt
+                in
                 [ Html.div [] [ Html.text &lt;| String.fromInt &lt;| Time.posixToMillis &lt;| posix ]
                 , Html.div [] [ Html.text &lt;| format posix ]
                 ]</code></pre>
<p>Done:</p>
<pre><code>$ make
shelm fetch
pruning stale dependency elm/my-elm-datetime-1.0.0
fetching https://github.com/robx/elm-datetime/archive/1.1.0.tar.gz
generating /s/elm-datetime/demo/elm-stuff/home/.elm/0.19.1/packages/registry.dat
shelm make --output=demo.js src/Demo.elm
Dependencies loaded from local cache.
Dependencies ready!
Success! Compiled 1 module.</code></pre>
<p>Still works! This time around, I used <a href="https://github.com/robx/shelm">shelm</a> to build the application via <code>make</code>.</p>
<figure>
<iframe title="elm-datetime demo, v2" src="/misc/elm-datetime-demo/v2.html" width="200" height="75">
</iframe>
<figcaption>
elm-datetime demo, v2
</figcaption>
</figure>
<p>You can find the full code for the package and demo app at <a href="https://github.com/robx/elm-datetime">github.com/robx/elm-datetime</a>, at releases <a href="https://github.com/robx/elm-datetime/releases/tag/1.0.0">1.0.0</a> and <a href="https://github.com/robx/elm-datetime/releases/tag/1.1.0">1.1.0</a>. The <code>shelm</code> package manager is available at <a href="https://github.com/robx/shelm">github.com/robx/shelm</a>.</p>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Guix and Elm, part 3: Deploying an Elm web application</title>
    <link href="https://vllmrt.net/spam/guix-elm-3.html" />
    <id>https://vllmrt.net/spam/guix-elm-3.html</id>
    <published>2019-11-27T00:00:00Z</published>
    <updated>2019-11-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>November 27, 2019</time>
        
        
    </section>
    <p>This is the third in a series of articles on working with Elm in Guix. See the <a href="guix-elm-1.html">first article</a> for an introduction. The outline is:</p>
<ol type="1">
<li><a href="guix-elm-1.html">packaging the Elm compiler</a></li>
<li><a href="guix-elm-2.html">developing Guix infrastructure for building Elm apps, and using this to package the Elm reactor, and the full Elm tool</a></li>
<li>deploying an Elm web application on Guix System</li>
</ol>
<p>In <a href="guix-elm-2.html">part 2</a> of this series, we ended up with a Guix package which outputs the compiled Javascript of our sample Elm applications:</p>
<pre><code>$ cat puzzle-draw.scm
(define-module (puzzle-draw)
  ...)

(define-public puzzle-draw-elm
  (package
    (name &quot;puzzle-draw-elm&quot;)
    (version &quot;current&quot;)
    (source &quot;/home/rob/puzzle-draw/web&quot;)
    (build-system elm-application-build-system)
    (arguments
      `(#:elm-modules (((&quot;Main.elm&quot;) . &quot;web.js&quot;)))))
    ...))

$ guix build -L . puzzle-draw-elm
[...]
/gnu/store/dd3i77nimvp17vgrak14yshd10mfm66c-puzzle-draw-elm-current
$ ls /gnu/store/dd3i77nimvp17vgrak14yshd10mfm66c-puzzle-draw-elm-current
web.js</code></pre>
<p>Below, we’ll figure out how to serve this up on Guix System via nginx:</p>
<ol type="1">
<li>Wrap <code>puzzle-draw-elm</code> in a package <code>puzzle-draw-frontend</code> that bundles a web server and static assets.</li>
<li>Define a Shepherd service to run that web server.</li>
<li>Configure the system to hook this server up to nginx, and redeploy it.</li>
</ol>
<h1 id="a-full-package-for-the-puzzle-draw-web-application">A full package for the puzzle-draw web application</h1>
<p>puzzle-draw comes with a web server executable that serves a backend API next to static content: <a href="https://github.com/robx/puzzle-draw/blob/master/src/serve/Main.hs">src/serve/Main.hs</a>, so we’ll go ahead and package the two together. Alternatively, we might package the static files separately from the backend API, and hook both up to the public-facing web server independently below.</p>
<p>Let’s assume we’ve packaged <code>puzzle-draw</code> already as a Haskell project. <a href="guix-elm-1.html">Part 1</a> goes into details of how to do that with the example of the <code>elm</code> tool.</p>
<pre><code>(define-public puzzle-draw
  (package
    (name &quot;puzzle-draw&quot;)
    (version &quot;current&quot;)
    (source &quot;/home/rob/puzzle-draw&quot;)
    (build-system haskell-build-system)
    ...
    (synopsis
     &quot;Creating graphics for pencil puzzles&quot;)
    (description
     &quot;puzzle-draw is a library and tool for drawing pencil puzzles using Diagrams.
    It aims to provide a utility layer on top of Diagrams to help with drawing arbitrary
    puzzles, and to support several specific puzzles types In addition, it includes
    functionality for parsing puzzle data from a YAML file format.&quot;)
    (license license:expat)))</code></pre>
<p>Then we can combine <code>puzzle-draw-elm</code> and <code>puzzle-draw</code> by providing a builder script to the trivial build system:</p>
<pre><code>(define-public puzzle-draw-frontend
  (package
    (name &quot;puzzle-draw-frontend&quot;)
    (version &quot;current&quot;)
    (source &quot;/home/rob/puzzle-draw&quot;)
    (build-system trivial-build-system)
    (inputs
     `((&quot;puzzle-draw&quot; ,puzzle-draw)
       (&quot;bash&quot; ,bash)))
    (native-inputs
     `((&quot;puzzle-draw-elm&quot; ,puzzle-draw-elm)))
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       (begin
         (use-modules (guix build utils))
         (let* ((elm (assoc-ref %build-inputs &quot;puzzle-draw-elm&quot;))
                (draw (assoc-ref %build-inputs &quot;puzzle-draw&quot;))
                (source (assoc-ref %build-inputs &quot;source&quot;))
                (bash (assoc-ref %build-inputs &quot;bash&quot;))
                (out (assoc-ref %outputs &quot;out&quot;)))
           (copy-recursively (string-append source &quot;/static&quot;) (string-append out &quot;/static&quot;))
           (copy-recursively (string-append source &quot;/tests/examples&quot;) (string-append out &quot;/tests/examples&quot;))
           (copy-recursively elm (string-append out &quot;/static&quot;))
           (install-file
            (string-append draw &quot;/bin/servepuzzle&quot;)
            (string-append out &quot;/bin&quot;))
           (setenv &quot;PATH&quot; (string-append (getenv &quot;PATH&quot;) &quot;:&quot; bash &quot;/bin&quot;))
           (wrap-program             (string-append out &quot;/bin/servepuzzle&quot;)
             `(&quot;PUZZLE_DRAW_ROOT&quot; &quot;:&quot; = (,out)))))))
    (description #f)
    (synopsis #f)
    (license #f)
    (home-page #f)))</code></pre>
<p>The trivial build system does nothing but run its <code>builder</code> argument. That’s a Guile script that has access to source, inputs and output directory, as well as any explicitly provide Guile modules.</p>
<p>We provide both <code>puzzle-draw</code> and <code>puzzle-draw-elm</code> as inputs, as well as <code>bash</code> since we’ll generate a wrapper shell script via <code>wrap-program</code> that will reference it.</p>
<aside>
<p>I’m a bit fuzzy on the distinction between <code>inputs</code> and <code>native-inputs</code>. In a cross-compilation setup, <code>inputs</code> will be built for the target, while <code>native-inputs</code> for the host. In that sense, it’s fine to put the Elm package in <code>native-inputs</code>, because the Javascript artifacts are platform-independent.</p>
But I can’t quite align this interpretation with the common use of <code>native-inputs</code> to specify dependencies that are used for unit tests, but not the final build products. The point being that unit tests would be run on the host system, while output artifacts are built for the target system.
</aside>
<p>Guix always provides us with a Guile interpreter; via the <code>modules</code> argument, we instruct it to make the <code>(guix build utils</code> module available to our script.</p>
<p>The script itself then merely copies our various ingredients to the output path, before wrapping <code>servepuzzle</code> in a shell-script that sets an environment variable to let the server know where to find its static files.</p>
<h1 id="a-puzzle-draw-shepherd-service">A puzzle-draw Shepherd service</h1>
<p>The <a href="https://www.gnu.org/software/shepherd/">GNU Shepherd</a> is Guix System’s <code>init</code>. It’s a Guile daemon originating as <code>dmd</code> with GNU Hurd.</p>
<aside>
Similar to Guix System’s Guile cron daemon <code>mcron</code>, I’m not convinced by the choice of Shepherd. It feels incomplete and lacking the robustness that I’d expect from a core system daemon. The choice of using these in Guix is probably down to a combination of wanting to do everything in Guile, and giving purpose to these projects.
</aside>
<p>To define this service within Guix, we define a new service type:</p>
<pre><code>(define-public puzzle-draw-service-type
  (service-type
   (name &#39;puzzle-draw)
   (extensions
    (list (service-extension shepherd-root-service-type
                             puzzle-draw-shepherd-service)
          (service-extension account-service-type
                             (const %puzzle-draw-accounts))))
   (default-value (puzzle-draw-configuration))))</code></pre>
<p>This references a couple of things. The <code>puzzle-draw-configuration</code> in this case is pure boilerplate, that’s used to pass in our base Guix package <code>puzzle-draw-frontend</code> while allowing it to be overridden:</p>
<pre><code>(define-record-type* &lt;puzzle-draw-configuration&gt;
  puzzle-draw-configuration make-puzzle-draw-configuration
  puzzle-draw-configuration?
  (puzzle-draw puzzle-draw-configuration-puzzle-draw (default puzzle-draw-frontend)))</code></pre>
<p>Other than that, there are two “service extensions”; these are defined as functions that take the service configuration and return a suitable “extension” of the given service type. In the case of <code>account-service-type</code>, that’s just a list of groups and accounts that doesn’t care about the configuration (whence <code>const</code>):</p>
<pre><code>(define %puzzle-draw-accounts
  (list (user-group (name &quot;pzldraw&quot;) (system? #t))
        (user-account
         (name &quot;pzldraw&quot;)
         (group &quot;pzldraw&quot;)
         (system? #t)
         (comment &quot;puzzle-draw server user&quot;)
         (home-directory &quot;/var/empty&quot;)
         (shell (file-append shadow &quot;/sbin/nologin&quot;)))))</code></pre>
<p>This sets up a dedicated for the puzzle-draw daemon; we could easily have skipped that part and run things as an existing user below.</p>
<p>The other extension is to <code>shepherd-service-type</code>:</p>
<pre><code>(define puzzle-draw-shepherd-service
  (match-lambda
    (($ &lt;puzzle-draw-configuration&gt; puzzle-draw-frontend)
     (list (shepherd-service
            (provision &#39;(puzzle-draw))
            (documentation &quot;Run the puzzle-draw daemon.&quot;)
            (requirement &#39;(user-processes))
            (start #~(make-forkexec-constructor
                      &#39;(#$(logger-wrapper &quot;puzzle-draw&quot; (file-append puzzle-draw-frontend &quot;/bin/servepuzzle&quot;)
                                          &quot;-b&quot; &quot;127.0.0.1&quot; &quot;-p&quot; &quot;8765&quot;))
                      #:user &quot;pzldraw&quot;
                      #:group &quot;pzldraw&quot;))
            (stop #~(make-kill-destructor)))))))</code></pre>
<p>This is mostly just us telling shepherd to run the <code>servepuzzle</code> executable, whose path we obtain from the <code>puzzle-draw-frontend</code> field in the configuration.</p>
<aside>
There’s something interesting happening with <code>puzzle-draw-frontend</code> here: Originally, we defined it as a Guix package expression. However, when a package moves to the build-side of things, it turns into a path in the store; I believe this is the core of what’s called “lowering” in the definition of a build system, as we encountered in <a href="guix-elm-2.html">part 2</a>. Check out the documentation on <a href="https://guix.gnu.org/manual/en/guix.html#G_002dExpressions">G-expressions</a> for a more informed discussion of this.
</aside>
<p>There’s one extra change we made here, namely wrapping the executable with logger:</p>
<pre><code>(define* (logger-wrapper name exec . args)
  &quot;Return a derivation that builds a script to start a process with
standard output and error redirected to syslog via logger.&quot;
  (define exp
    #~(begin
        (use-modules (ice-9 popen))
        (let* ((pid    (number-&gt;string (getpid)))
               (logger #$(file-append inetutils &quot;/bin/logger&quot;))
               (args   (list &quot;-t&quot; #$name (string-append &quot;--id=&quot; pid)))
               (pipe   (apply open-pipe* OPEN_WRITE logger args)))
          (dup pipe 1)
          (dup pipe 2)
          (execl #$exec #$exec #$@args))))
  (program-file (string-append name &quot;-logger&quot;) exp))</code></pre>
<p>This is required because, by default, <a href="https://debbugs.gnu.org/cgi/bugreport.cgi?bug=36264">Shepherd is happy</a> to let its child processes dump their output to Shepherd’s <code>stdout</code>, i.e. the console, where it will never be seen. Note that the <code>#~(begin</code>, <code>#$</code>, <code>#$@</code> magic here is the G-expressions version of Scheme quasi-quoting, allowing us to mix host and target code.</p>
<h1 id="configuring-the-system">Configuring the system</h1>
<p>Now to bring our new service live. Our Guix system is defined by an <code>operating-system</code> record which comes with a list of services:</p>
<pre><code>(operating-system
  (host-name &quot;garp&quot;)
  (timezone &quot;Europe/Berlin&quot;)
  (locale &quot;en_US.utf8&quot;)
  ...
  (services
   (append
    (list
     (static-networking-service &quot;eth0&quot; ...)
     (service openssh-service-type ...)
     ...)
    %base-services)))</code></pre>
<p>To set up nginx and puzzle-draw, we add two services:</p>
<pre><code>     (service openssh-service-type ...)
     (service nginx-service-type
              (nginx-configuration
               (extra-content
                #~(string-append
                   (string-append &quot;    include &quot; #$(local-file &quot;nginx/garp&quot;) &quot;;\n&quot;)))))
     (service puzzle-draw-service-type)
     ...</code></pre>
<p>The nginx include directive allows us to write a plain nginx fragment, rather than do everything in Guile. Here’s <code>nginx/garp</code>:</p>
<pre><code>server {
        listen 443 ssl default_server;
        listen [::]:443 ssl default_server;
        server_name garp.vllmrt.net;
        ssl_certificate /etc/letsencrypt/live/garp.vllmrt.net/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/garp.vllmrt.net/privkey.pem;

        ...

        location /puzzles/draw/ {
                proxy_pass http://127.0.0.1:8765/;
        }
}</code></pre>
<aside>
I can’t find the documentation of this right now, but the way Guix System integrates certbot/letsencrypt with nginx is pretty neat. It automatically hooks in an nginx service extension, serving the relevant <code>.well-known</code> path over HTTP and redirecting to HTTPS.
</aside>
<p>Ideally, we’d template this fragment somehow so we don’t have to hard-code the port number in two places, but this works for now.</p>
<p>Finally, we can reconfigure the system:</p>
<pre><code>$ sudo guix system reconfigure config.scm
$ sudo herd restart nginx</code></pre>
<aside>
<p>Reconfiguring the system will automatically start new services, such as <code>puzzle-draw</code>. On the other hand, since I was already running nginx, I had to restart it to pick up the updated configuration (not just tell it to reload its config, the path changed!).</p>
The whole reconfiguration story is a bit of a mess: If I found out I made a mistake and wanted to roll back, the quickest would be to manually undo the change in the configuration and call <code>guix system reconfigure</code> again. <code>guix system roll-back</code> <a href="https://debbugs.gnu.org/cgi/bugreport.cgi?bug=36855">won’t pick up the old service setup without a reboot</a>.
</aside>
<p>Done! <a href="https://garp.vllmrt.net/puzzles/draw/">Draw some puzzles</a>!</p>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Guix and Elm, part 2: An Elm build system</title>
    <link href="https://vllmrt.net/spam/guix-elm-2.html" />
    <id>https://vllmrt.net/spam/guix-elm-2.html</id>
    <published>2019-11-27T00:00:00Z</published>
    <updated>2019-12-03</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>November 27, 2019</time>
        
        
    </section>
    <aside>
Updated 2019-12-03: Add link to guix-devel email discussing Elm packaging.
</aside>
<p>This is the second in a series of articles on working with Elm in Guix. See the <a href="guix-elm-1.html">first article</a> for an introduction. The outline is:</p>
<ol type="1">
<li><a href="guix-elm-1.html">packaging the Elm compiler</a></li>
<li>developing Guix infrastructure for building Elm apps, and using this to package the Elm reactor, and the full Elm tool</li>
<li><a href="guix-elm-3.html">deploying an Elm web application on Guix System</a></li>
</ol>
<p>In part 1, we succeeded in packaging the Elm compiler. We now have the <code>elm</code> tool available, and can use it to build an Elm application from the command line. I’ll use a small Elm app of mine for demonstration purposes, the web interface to <a href="https://github.com/robx/puzzle-draw">puzzle-draw</a>.</p>
<aside>
puzzle-draw is a tool for generating pencil puzzle graphics, written in Haskell. I wrote a web frontend for it in Elm; the source can be found in the subdirectory <a href="https://github.com/robx/puzzle-draw/tree/master/web"><code>puzzle-draw/web</code></a>, and it’s presently hosted at <a href="https://garp.vllmrt.net/puzzles/draw">garp.vllmrt.net/puzzles/draw</a>.
</aside>
<p>In this article, we’ll develop Guix tooling to allow us to package and build this web app, and to package the full <code>elm</code> tool including the reactor. You can find the code in the last couple of commits of the <code>elm</code> branch here: <a href="https://github.com/robx/guix/tree/elm/">github.com/robx/guix</a>.</p>
<aside>
It’s going to get pretty technical, and I won’t be going into as much detail as in part 1. In a similar vein, the code gets a bit messy, because at some point there’s just <em>so much</em> to do that I ran out of will to figure out clean ways to do things. Hopefully, this article might at least show what kind of experience to expect if you try something like this at home.
</aside>
<h1 id="building-the-application-without-guix">Building the application without Guix</h1>
<p>To begin, let’s have a look at what happens when we build the application from the command line. We’ll start by wiping out Elm’s package cache.</p>
<pre><code>$ rm -rf ~/.elm
$ git clone https://github.com/robx/puzzle-draw.git &amp;&amp; cd puzzle-draw/web
$ elm make --output=../static/web.js src/Main.elm
Starting downloads...

  ● elm/time 1.0.0
  ● elm/json 1.0.0
  ● elm/url 1.0.0
  ● elm/browser 1.0.0
  ● elm/virtual-dom 1.0.0
  ● elm/html 1.0.0
  ● elm/core 1.0.0
  ● elm/http 1.0.0

Dependencies ready!                
Success! Compiled 1 module.                                          </code></pre>
<p>So <code>elm make</code> can successfully build our application, based on the definition in <code>elm.json</code>:</p>
<pre><code>$ cat elm.json
{
    &quot;type&quot;: &quot;application&quot;,
    &quot;source-directories&quot;: [
        &quot;src&quot;
    ],
    &quot;elm-version&quot;: &quot;0.19.0&quot;,
    &quot;dependencies&quot;: {
        &quot;direct&quot;: {
            &quot;elm/browser&quot;: &quot;1.0.0&quot;,
            &quot;elm/core&quot;: &quot;1.0.0&quot;,
            &quot;elm/html&quot;: &quot;1.0.0&quot;,
            &quot;elm/http&quot;: &quot;1.0.0&quot;,
            &quot;elm/json&quot;: &quot;1.0.0&quot;,
            &quot;elm/url&quot;: &quot;1.0.0&quot;
        },
        &quot;indirect&quot;: {
            &quot;elm/time&quot;: &quot;1.0.0&quot;,
            &quot;elm/virtual-dom&quot;: &quot;1.0.0&quot;
        }
    },
    &quot;test-dependencies&quot;: {
        &quot;direct&quot;: {},
        &quot;indirect&quot;: {}
    }
}</code></pre>
<p>With an empty package database and missing <code>./elm-stuff</code>, <code>elm make</code> goes through:</p>
<ol type="1">
<li><p>Pull a database of available package versions from <code>package.elm-lang.org</code>, and write it to <code>~/.elm/0.19.0/package/versions.dat</code>.</p></li>
<li><p>Download the dependency source packages from Github, and unpack them in <code>~/.elm</code> and update the package database:</p>
<pre><code>$ find ~/.elm/ | grep elm/url
~/.elm/0.19.0/package/elm/url
~/.elm/0.19.0/package/elm/url/1.0.0
~/.elm/0.19.0/package/elm/url/1.0.0/src
~/.elm/0.19.0/package/elm/url/1.0.0/src/Url.elm
[...]</code></pre></li>
<li><p>Compile some auxiliary files from the dependency sources within <code>~/.elm</code>:</p>
<pre><code>$ find ~/.elm/ | grep &#39;elm/url.*\.dat$&#39;
~/.elm/0.19.0/package/elm/url/1.0.0/ifaces.dat
~/.elm/0.19.0/package/elm/url/1.0.0/cached.dat
~/.elm/0.19.0/package/elm/url/1.0.0/objs.dat</code></pre></li>
<li><p>Compile the application sources into <code>elm-stuff</code>:</p>
<pre><code>$ find elm-stuff/
elm-stuff/
elm-stuff/0.19.0
elm-stuff/0.19.0/summary.dat
elm-stuff/0.19.0/Main.elmo
elm-stuff/0.19.0/Main.elmi</code></pre></li>
<li><p>Generate output Javascript.</p></li>
</ol>
<p>It’s only really steps 1 and 2 that are interesting for us here. We can happily let <code>elm make</code> do its stuff in steps 3-5 within the Guix sandbox.</p>
<p>However, building for Guix, we can’t allow steps 1 and 2 as is both since they require network access, and since we need to explicitly provide all dependencies with hashes for a Guix package. Luckily, it turns out that <code>elm make</code> does work absent network access if <code>~/.elm</code> is in the right state. It needs:</p>
<ul>
<li>A valid <code>versions.dat</code> file that contains at least all the dependencies listed in our application’s <code>elm.json</code>.</li>
<li>Unpacked source archives for the dependencies as listed above.</li>
<li>An (empty) <code>elm-stuff</code> directory.</li>
</ul>
<h1 id="build-systems">Build systems</h1>
<p>Every Guix package specifies a <a href="https://guix.gnu.org/manual/en/html_node/Build-Systems.html">build system</a>, which determines in pretty full generality how the package definition is converted into an output in the Guix store.</p>
<p>In the Elm case, it makes sense to treat (Elm) packages and applications separately:</p>
<ul>
<li><p>We only need Elm packages to provide source files for application builds. Building an Elm package will simply amount to downloading and unpacking a source archive.</p></li>
<li><p>For Elm applications, we want to call <code>elm make</code> to compile the Elm source files to Javascript.</p></li>
</ul>
<aside>
It would be possible to make the Elm package build system compile the files that <code>elm make</code> generates within <code>~/.elm</code>, e.g. <code>~/.elm/0.19.0/package/elm/url/1.0.0/ifaces.dat</code>. These could then be reused to speed up builds of dependents.
</aside>
<p>Build systems consist of two parts: A core build script, which resides within <code>guix/build</code>. This is build-side code, executed within the Guix sandbox. In our case, this will be two functions <code>elm-package-build</code> and <code>elm-application-build</code>, defined in <a href="https://github.com/robx/guix/blob/elm/guix/build/elm-build-system.scm"><code>guix/build/elm-build-system.scm</code></a>.</p>
<p>Then, there’s a bunch of user-side scaffolding, assembling build ingredients and passing them to the build side. In our case, this will primarily be two build-system records <code>elm-package-build-system</code> and <code>elm-application-build-system</code>, defined in <a href="https://github.com/robx/guix/blob/elm/guix/build-system/elm.scm"><code>guix/build-system/elm.scm</code></a>.</p>
<aside>
Not at all sure “user-side” is the best term here. I mean the Guile code that defines the packages and that’s part of the user-facing Guix tooling such as <code>guix package</code>.
</aside>
<aside>
Guix’ build system zoo is a bit of a mess. There’s a base <code>trivial-build-system</code> which does nothing (not even know how to extract source archives). So almost all other build systems are based on <code>gnu-build-system</code>, which provides generally useful features (a notion of multiple build phases; unpacking source archives), but also wants to run a standard Gnu <code>configure; make; make install</code> build, pulling in dependencies that are unnecessary for other build styles. Some reorganization would be good here.
</aside>
<aside>
Another issue with the build systems is that they don’t compose well. Here, we’ll define a build system that deals with compiling Elm sources. But typically, an Elm application will also come with some static HTML and CSS files – it would be great to be able to mix in a build system that deals with copying over static content. Instead, what we’ll have to do is define a package for the Elm compilation, and then a second package for the static content that receives the first package as an input. Compare <a href="guix-elm-3.html">part 3</a> of this series.
</aside>
<p>Here’s what an Elm-package-package might look like. <code>(build-system elm-package-build-system)</code> here tells Guix to use that build system.</p>
<pre><code>(define-public elm-virtual-dom
  (package
    (name &quot;elm-virtual-dom&quot;)
    (version &quot;1.0.0&quot;)
    (source
     (origin
       (method url-fetch)
       (uri (elm-package-uri &quot;elm/virtual-dom&quot; version))
       (sha256
        (base32
         &quot;0hm8g92h7z39km325dlnhk8n00nlyjkqp3r3jppr37k2k13md6aq&quot;))))
    (build-system elm-package-build-system)
    (synopsis
     &quot;Core virtual DOM implementation, basis for HTML and SVG libraries&quot;)
    (description
     &quot;Core virtual DOM implementation, basis for HTML and SVG libraries&quot;)
    (home-page #f)
    (license license:bsd-3)))</code></pre>
<p>Below, we’ll go over the build side code in some detail, and skim the build system definition as such.</p>
<h2 id="elm-package-build"><code>elm-package-build</code></h2>
<p>The core of the package build system is the function <code>elm-package-build</code>, which simply unpacks the source archive, and copies it to the output path.</p>
<p>The function is called with three arguments:</p>
<dl>
<dt><code>source</code></dt>
<dd><p>A path to the source, as specified in the package definition.</p>
</dd>
<dt><code>inputs</code></dt>
<dd><p>An association list mapping input names to paths. This includes the various explicit dependencies we could have listed in the package definition’s <code>input</code> fields, as well as dependencies specified by the build-system, such as the <code>tar</code> tool.</p>
</dd>
<dt><code>output</code></dt>
<dd><p>A store path that we’re meant to write our result to.</p>
</dd>
</dl>
<pre><code>(define (elm-package-build source inputs output)
  (let ((tar (assoc-ref inputs &quot;tar&quot;))
        (gzip (assoc-ref inputs &quot;gzip&quot;)))
    (setenv &quot;PATH&quot; (string-append (getenv &quot;PATH&quot;) &quot;:&quot;
                                  (string-append tar &quot;/bin&quot;) &quot;:&quot;
                                  (string-append gzip &quot;/bin&quot;)))
    (mkdir &quot;source&quot;)
    (with-directory-excursion &quot;source&quot;
      (invoke &quot;tar&quot; &quot;xzf&quot; source)
      (let ((dir (car (scandir &quot;.&quot; (lambda (f) (&gt; (string-length f) 2))))))
        (copy-recursively dir output)))))</code></pre>
<h2 id="build-versions.dat"><code>build-versions.dat</code></h2>
<p>A first ingredient that our application build system needs is way to generate the Elm package database <code>versions.dat</code>.</p>
<p>To interact with it, <code>elm make</code> uses the Haskell <a href="https://hackage.haskell.org/package/binary">binary</a> package. The core of the relevant code can be found in <a href="https://github.com/elm/compiler/blob/0.19.0/compiler/src/Elm/Package.hs#L350"><code>Elm/Package.hs</code></a>. It’s a pretty straightforward encoding, we mostly have to ensure we order entries correctly matching the Haskell encoding of maps. Using the module <a href="https://www.gnu.org/software/guile/manual/html_node/Binary-I_002fO.html"><code>(ice-9 binary-ports)</code></a>, here’s an implementation.</p>
<pre><code>(define* (put-packages port pkgs)
  &quot;Writes an elm package database to PORT based on the
list PKGS of packages. Each package should be a list
of the form &#39;(\&quot;elm\&quot; \&quot;core\&quot; (1 0 0)).&quot;

  (define (put-int64 port x)
    (let ((vec (make-bytevector 8)))
      (bytevector-s64-set! vec 0 x (endianness big))
      (put-bytevector port vec)))

  (define (put-text port s)
    (put-int64 port (string-length s)) ; this should be utf8 length, utf8
    (put-string port s))

  (define (put-version port v)
    (map (cut put-u8 port &lt;&gt;) v)) ; there&#39;s a different encoding for very large versions

  (define (put-package port pkg)
    (match pkg
      ((author project version)
       (begin
         (put-text port author)
         (put-text port project)
         (put-int64 port 1)
         (put-version port version)))))

  (put-int64 port (length pkgs)) ; total number of versions
  (put-int64 port (length pkgs)) ; number of packages
  (for-each
   (cut put-package port &lt;&gt;) 
   (sort pkgs (match-lambda*
                (((auth1 proj1 _) (auth2 proj2 _))
                 (or (string&lt;? auth1 auth2)
                     (and (string=? auth1 auth2)
                          (string&lt;? proj1 proj2))))))))</code></pre>
<p>Using this, we can define a (hacky) function to build a <code>versions.dat</code> file that matches a package tree:</p>
<pre><code>(define* (parse-version version)
  &quot;Parse an elm package version from string to a list of
integer components.&quot;
  (map string-&gt;number (string-split version #\.)))

(define* (build-versions.dat)
  &quot;Build an elm package database in the file versions.dat
in the current directory to match the existing unpacked elm
modules.&quot;
  (format #t &quot;building versions.dat in ~a~%&quot; (getcwd))
  (let ((packages (string-split
                   (get-line (open-input-pipe &quot;echo */*/*&quot;))
                   #\ ))
        (out (open-output-file &quot;versions.dat&quot;)))
    (format #t &quot;packages: ~a~%&quot; packages)
    (put-packages
     out
     (map
      (lambda (path)
        (match (string-split path #\/)
          ((author project version)
           (list author project (parse-version version)))))
      packages))
    (close out)))</code></pre>
<h2 id="elm-application-build"><code>elm-application-build</code></h2>
<p>The core of the Elm application build system is the function <code>elm-application-build</code>. We’ll walk through it now.</p>
<pre><code>(define (elm-application-build source inputs output elm-modules)</code></pre>
<p>The arguments to <code>elm-application-build</code> are like those for <code>elm-package-build</code> above, with two modifications: We’ll find that the source archive is redundantly available as an input with key “source” – I’m not sure if this is generally the case, and why we should be using this and not the <code>source</code> argument below, but there must have been a Good Reason.</p>
<p>Then, we pass an extra argument <code>elm-modules</code> to determine how to call <code>elm make</code>. The default is <code>((("Main.elm") . "main.js"))</code>, stating that we want to generate one Javascript file <code>main.js</code> by compiling the Elm module <code>Main.elm</code>.</p>
<aside>
It’s a bit annoying to have to specify this information when defining a package. An alternative might be to instead call <code>make build</code> if there’s a <code>Makefile</code> in the source directory, and just copy out all <code>.js</code>-files.
</aside>
<pre><code>  (let ((elm (string-append (assoc-ref inputs &quot;elm-compiler&quot;) &quot;/bin/elm&quot;))
        (deps &quot;.elm/0.19.0/package&quot;)
        (tar (assoc-ref inputs &quot;tar&quot;))
        (xz (assoc-ref inputs &quot;xz&quot;)))
    (setenv &quot;PATH&quot; (string-append (getenv &quot;PATH&quot;) &quot;:&quot;
                                  (string-append tar &quot;/bin&quot;) &quot;:&quot;
                                  (string-append xz &quot;/bin&quot;)))</code></pre>
<p>We start by setting some variables. In particular, we set up <code>$PATH</code> to allow the <code>unpack</code> function we copied from some other build system to work later on.</p>
<pre><code>    (format #t &quot;collecting dependencies~%&quot;)
    (mkdir-p deps)
    (for-each
      (match-lambda
        ((n . pkg)
         (when (and (string-prefix? &quot;elm-&quot; n)
                    (not (equal? &quot;elm-compiler&quot; n)))
           (match (elm-package-and-version pkg)
             ((name . version)
              (copy-recursively pkg
                                (string-append deps &quot;/&quot; name &quot;/&quot; version)))))))
      inputs)</code></pre>
<p>Next we start setting up our package directory. We loop over all inputs, filtering for those that seem to be Elm packages. This is a terrible way to do things, but seems to be par for the course when comparing other build systems. A more reliable way might be to check whether there’s an <code>elm.json</code> file in the root directory of an input.</p>
<p>By assumption, these inputs are unpacked source archives, which we copy to the correct place in <code>~/.elm/0.19.0/package</code>.</p>
<pre><code>    (format #t &quot;generating versions.dat~%&quot;)
    (with-directory-excursion deps (build-versions.dat))</code></pre>
<p>With this done, we call out to our helper to generate a package database fitting the set of unpacked packages.</p>
<pre><code>    (format #t &quot;setting up elm env: cwd=~a~%&quot; (getcwd))
    (setenv &quot;HOME&quot; (getcwd))
    (setenv &quot;HTTP_PROXY&quot; &quot;.&quot;)
    (mkdir &quot;src&quot;) ; extra level of src directory because unpack uses the first subdir...
    (with-directory-excursion &quot;src&quot;
      (format #t &quot;extracting source~%&quot;)
      (unpack #:source (assoc-ref inputs &quot;source&quot;)) ; changes directory
      (mkdir &quot;elm-stuff&quot;)
      (chmod &quot;elm-stuff&quot; #o775)</code></pre>
<p>Now we set up things to trick <code>elm make</code> into happiness: We set <code>$HOME</code> to point at the package database we generated, set <code>$HTTP_PROXY</code> to cleanly break network access, unpack the source archive (in a bit of a messy way because that’s how <code>unpack</code> works, and finally generate an empty <code>elm-stuff</code> directory.</p>
<pre><code>      (for-each
        (match-lambda
          ((srcs . dst)
           (begin
             (format #t &quot;building ~a from ~a~%&quot; dst srcs)
             (apply invoke elm &quot;make&quot; (string-append &quot;--output=&quot; output &quot;/&quot; dst)
                    (map (lambda (src) (string-append &quot;src/&quot; src)) srcs)))))
        elm-modules))))</code></pre>
<p>Finally, we loop over the <code>elm-modules</code> argument, calling <code>elm make</code> with target in the output directory.</p>
<h2 id="the-build-systems-proper">The build systems proper</h2>
<p>We define the two Elm build systems in <code>guix/build-system/elm.scm</code>:</p>
<pre><code>(define elm-package-build-system
  (build-system
    (name &#39;elm-package)
    (description
     &quot;Elm package build system, merely unpacking the source archive.&quot;)
    (lower lower-package)))

(define elm-application-build-system
  (build-system
    (name &#39;elm-application)
    (description
     &quot;Elm application build system.&quot;)
    (lower lower-application)))</code></pre>
<p>The rest of the file is more or less boiler plate, to pass between the user-side and the build-side code. There’s some hope this will become cleaner once the build systems are converted to use <a href="">G-expressions</a>. For the moment it didn’t seem worthwhile really trying to understand this part; I was content to get it to work.</p>
<p>Here’s the implementation of <code>lower-application</code>:</p>
<pre><code>(define* (lower-application name
                #:key source inputs native-inputs outputs system target
                guile builder modules allowed-references
                (elm-modules &#39;(((&quot;Main.elm&quot;) . &quot;main.js&quot;))))
  &quot;Return a bag for NAME.&quot;
  (bag
    (name name)
    (system system)
    (target target)
    (host-inputs `(,@(if source
                         `((&quot;source&quot; ,source))
                         &#39;())
                   (&quot;elm-compiler&quot; ,(elm-compiler))
                   ,@inputs
                   ,@(gnu:standard-packages)))
    (build-inputs `(,@native-inputs))
    (outputs outputs)
    (build elm-application-build)
    (arguments `(#:guile ,guile
                 #:modules ,modules
                 #:elm-modules ,elm-modules
                 #:allowed-references ,allowed-references))))</code></pre>
<p>I don’t understand this well enough to explain everything; important parts are:</p>
<ul>
<li><p>We pass in the Elm compiler itself as an input, so it’ll be available to <code>elm-application-build</code>.</p></li>
<li><p>We pass through the <code>elm-modules</code> argument, allowing it to be specified as a package argument like this:</p>
<pre><code>(package
  ...
  (build-system elm-application-build-system)
  (arguments
    `(#:elm-modules (((&quot;Main.elm&quot;) . &quot;main.js&quot;))))
  ...)</code></pre></li>
</ul>
<h1 id="an-elm-application-importer">An Elm application importer</h1>
<p>At this point we could write Elm package definitions by hand. However, that’s a bit unwieldy, so I went on and implemented <code>guix import elm</code>, which takes an <code>elm.json</code> file and generates a package definition.</p>
<p>The core of the importer is defined in <code>guix/import/elm.scm</code>, with some helper code in <code>guix/scripts/import/elm.scm</code> to deal with the command line interface. The gist of the code is:</p>
<ul>
<li>Parse an <code>elm.json</code> file (<code>elm.json-&gt;guix-package</code>).</li>
<li>If it’s an Elm package, just assemble (<code>make-elm-package-sexp</code>) the <code>elm.json</code> fields into a Guix package, together with URL and hash of the source archive.</li>
<li>Else, collect the list of dependencies, and recurse to assemble each of those into a local package definition as above, and then assemble it into a Guix package definition.</li>
</ul>
<p>Here’s an extract of the code:</p>
<pre><code>(define (make-elm-package-sexp name version summary license)
  `(package
     (name ,(elm-package-name name))
     (version ,version)
     (source (origin
               (method url-fetch)
               (uri (elm-package-uri ,name version))
               (sha256
                (base32
                 ,(guix-hash-url (elm-package-uri name version))))))
     (build-system elm-package-build-system)
     (synopsis ,summary)
     (description ,summary)
     (home-page #f)
     (license ,(spdx-string-&gt;license license))))

(define (elm.json-&gt;guix-package elm.json)
  &quot;Read package metadata from the given ELM.JSON file, and return
the `package&#39; s-expression corresponding to that package.&quot;
  (let ((type    (assoc-ref elm.json &quot;type&quot;)))
    (cond
      ((equal? type &quot;package&quot;)
         (let* ((name    (assoc-ref elm.json &quot;name&quot;))
                (version (assoc-ref elm.json &quot;version&quot;))
                (license (assoc-ref elm.json &quot;license&quot;))
                (summary (assoc-ref elm.json &quot;summary&quot;)))
           (make-elm-package-sexp name version summary license)))
      ((equal? type &quot;application&quot;)
         (make-elm-app-sexp
           (map (match-lambda ((name . version)
                               `(,(elm-package-name name) . ,(elm-&gt;guix-package name version))))
                (get-dependencies elm.json))))
      (else
         (error &quot;unsupported elm package type: &quot; type)))))</code></pre>
<p>Running this on <code>elm.json</code> within the <code>puzzle-draw</code> sources now gives us an almost-ready package:</p>
<pre><code>(let ((elm-url
        (package
          (name &quot;elm-url&quot;)
          (version &quot;1.0.0&quot;)
          (source
            (origin
              (method url-fetch)
              (uri (elm-package-uri &quot;elm/url&quot; version))
              (sha256
                (base32
                  &quot;0av8x5syid40sgpl5vd7pry2rq0q4pga28b4yykn9gd9v12rs3l4&quot;))))
          (build-system elm-package-build-system)
          (synopsis
            &quot;Create and parse URLs. Use for HTTP and \&quot;routing\&quot; in single-page apps (SPAs)&quot;)
          (description
            &quot;Create and parse URLs. Use for HTTP and \&quot;routing\&quot; in single-page apps (SPAs)&quot;)
          (home-page #f)
          (license license:bsd-3)))
      (elm-json
        ...)
      ...)
  (package
    (name #f)
    (version #f)
    (source #f)
    (build-system elm-application-build-system)
    (native-inputs
      `((&quot;elm-url&quot; ,elm-url)
        (&quot;elm-json&quot; ,elm-json)
        (&quot;elm-http&quot; ,elm-http)
        (&quot;elm-html&quot; ,elm-html)
        (&quot;elm-core&quot; ,elm-core)
        (&quot;elm-browser&quot; ,elm-browser)
        (&quot;elm-virtual-dom&quot; ,elm-virtual-dom)
        (&quot;elm-time&quot; ,elm-time)))
    (synopsis #f)
    (description #f)
    (home-page #f)
    (license #f)))</code></pre>
<aside>
<p>I’ve decided to define dependency packages locally within the package definition using that <code>let</code> clause. It wouldn’t really make sense to define say a global <code>elm-url</code> package at version <code>1.0.0</code>, because Elm applications specify fixed dependency versions. So to share dependencies within the global package set, we’d need versioned identifiers, which seems contrary to how Guix typically does things.</p>
<p>Note that the paths within the Guix store will still be shared, this is merely about sharing the Guile expression defining the dependency.</p>
See also this <a href="https://lists.gnu.org/archive/html/guix-devel/2019-07/msg00139.html">email to guix-devel</a>.
</aside>
<p>As you see, some fields have been left out, because <code>elm.json</code> doesn’t specify them for applications. Most importantly, we need to fill the source field, such as this:</p>
<pre><code>(define-public puzzle-draw-elm
  (let ((elm-url ...) ...)
    (package
      (name &quot;puzzle-draw-elm&quot;)
      (version &quot;current&quot;)
      (source &quot;/home/rob/puzzle-draw/web&quot;)
      (build-system elm-application-build-system)
      (arguments
        `(#:elm-modules (((&quot;Main.elm&quot;) . &quot;web.js&quot;))))
      ...)))</code></pre>
<p>Here, we’re not defining a “proper” origin for the source, but just telling Guix to use a local checkout.</p>
<aside>
<p>There are downsides to using a local path like this. One that I keep running into is that this will copy the whole directory tree, including for example an <code>elm-stuff</code> directory, which will cause the build to fail.</p>
So far, I haven’t succeeded in telling Guix to use a given commit from a local git repository. Ideally, when building locally, I’d like to be able to tell it to build from the <code>master</code> or <code>release</code> branch, without giving a hash.
</aside>
<p>It works!</p>
<pre><code>$ guix build -L . puzzle-draw-elm
[...]
/gnu/store/dd3i77nimvp17vgrak14yshd10mfm66c-puzzle-draw-elm-current
$ ls /gnu/store/dd3i77nimvp17vgrak14yshd10mfm66c-puzzle-draw-elm-current
web.js</code></pre>
<h1 id="packaging-the-elm-reactor">Packaging the Elm reactor</h1>
<p>Finally, let’s use our new build systems to package Elm more fully. We can package the reactor web app by calling</p>
<pre><code>$ guix import elm ui/browser/elm.json</code></pre>
<p>within the Elm compiler repository. With some tweaks, we get</p>
<pre><code>(define elm-reactor
  (let
      ((elm-virtual-dom ...)
      ...)
      (package
      (name &quot;elm-reactor&quot;)
      (version &quot;0.19.0&quot;)
      (source
       (origin
         (method url-fetch)
         (file-name &quot;elm-0.19.0.tar.gz&quot;)
         (uri &quot;https://github.com/elm/compiler/archive/0.19.0.tar.gz&quot;)
         (sha256
          (base32 &quot;0g4risrjrvngz3j4wf432j82gjcc8i1b7l5lwbb0fhr24hvz6ka9&quot;))
         ; FIXME: extract reactor subdirectory, there must be a better way to do this
         (snippet #~(begin
                      (use-modules (guix build utils) (ice-9 ftw))
                      (let ((files (scandir &quot;.&quot; (lambda (f) (not (or (equal? f &quot;.&quot;)
                                                                     (equal? f &quot;..&quot;)
                                                                     (equal? f &quot;ui&quot;)))))))
                        (for-each delete-file-recursively files)
                        (copy-recursively &quot;ui/browser&quot; &quot;.&quot;)
                        (delete-file-recursively &quot;ui&quot;))))))
      (build-system elm-application-build-system)
      (arguments &#39;(#:elm-modules (((&quot;Errors.elm&quot; &quot;Index.elm&quot; &quot;NotFound.elm&quot;) . &quot;elm.js&quot;))))
      (native-inputs
       `((&quot;elm-virtual-dom&quot; ,elm-virtual-dom)
         (&quot;elm-parser&quot; ,elm-parser)
         (&quot;elm-time&quot; ,elm-time)
         (&quot;elm-url&quot; ,elm-url)
         (&quot;elm-svg&quot; ,elm-svg)
         (&quot;elm-core&quot; ,elm-core)
         (&quot;elm-http&quot; ,elm-http)
         (&quot;elm-html&quot; ,elm-html)
         (&quot;elm-json&quot; ,elm-json)
         (&quot;elm-markdown&quot; ,elm-markdown)
         (&quot;elm-project-metadata-utils&quot;
          ,elm-project-metadata-utils)
         (&quot;elm-browser&quot; ,elm-browser)))
      (synopsis &quot;Elm&#39;s reactor, internal to elm&quot;)
      (description &quot;Elm&#39;s reactor&quot;)
      (home-page &quot;https://elm-lang.org&quot;)
      (license bsd-3))))</code></pre>
<p>The interesting bit is the source manipulation snippet, which succeeds in manipulating the source tree to consist of the reactor sources only, in a horrendously messy way. Additionally, we list the Elm source files as the <code>elm-modules</code> argument.</p>
<p>With our new <code>elm-reactor</code> package, we can build the full Elm tool, by modifying the packaging from the <a href="">previous article</a> slightly:</p>
<pre><code>(define-public elm
  (package
    (name &quot;elm&quot;)
    (version &quot;0.19.0&quot;)
    (source
     (origin
       (method git-fetch)
       (file-name (git-file-name name version))
       (uri (git-reference
             (url &quot;https://github.com/elm/compiler/&quot;)
             (commit version)))
       (sha256
        (base32 &quot;0s93z9vr0vp5w894ghc5s34nsq09sg1msf59zfiba87sid5vgjqy&quot;))
       (patches
        (search-patches &quot;elm-include-reactor.patch&quot;
                        &quot;elm-compiler-relax-glsl-bound.patch&quot;
                        &quot;elm-compiler-fix-map-key.patch&quot;))))</code></pre>
<p>The first difference is that instead of patching out the reactor, we patch the build to read a Javascript file from disk instead of calling out to itself:</p>
<pre><code>$ cat elm-include-reactor.patch
diff --git a/ui/terminal/src/Develop/StaticFiles.hs b/ui/terminal/src/Develop/StaticFiles.hs
index 3659d112..f77635c7 100644
--- a/ui/terminal/src/Develop/StaticFiles.hs
+++ b/ui/terminal/src/Develop/StaticFiles.hs
@@ -89,7 +89,7 @@ sansFontPath =
 
 elm :: BS.ByteString
 elm =
-  $(bsToExp =&lt;&lt; runIO Build.compile)
+  $(bsToExp =&lt;&lt; runIO (Build.readAsset &quot;elm.js&quot;))
 
 
 </code></pre>
<p>Continuing,</p>
<pre><code>    (build-system haskell-build-system)
    (arguments
     `(#:phases
       (modify-phases %standard-phases
         (add-after &#39;unpack &#39;unpack-reactor
           (lambda* (#:key inputs #:allow-other-keys)
             (copy-file
              (string-append (assoc-ref inputs &quot;elm-reactor&quot;) &quot;/elm.js&quot;)
              &quot;ui/browser/assets/elm.js&quot;))))))</code></pre>
<p>we add a phase to the build to copy over that Javascript file from <code>elm-reactor</code> after unpacking the Elm sources.</p>
<pre><code>    (inputs
     `((&quot;elm-reactor&quot; ,elm-reactor)
       (&quot;ghc-ansi-terminal&quot; ,ghc-ansi-terminal)
       ...))
    (home-page &quot;https://elm-lang.org&quot;)
    (synopsis &quot;The `elm` command line interface, including `elm reactor`.&quot;)
    (description
     &quot;This package provides Elm, a statically-typed functional programming
language for the browser.  It includes commands for developers such as
@command{elm make} and @command{elm repl}.&quot;)
    (license license:bsd-3)))</code></pre>
<p>We add <code>elm-reactor</code> to the inputs, and it’s done.</p>
<pre><code>$ guix package -i elm
[...]
The following package will be installed:
   elm	0.19.0	/gnu/store/sfj3rdx3rlc6mgnwgs7y7vhkvpbvdxpn-elm-0.19.0
[...]
$ elm reactor
Go to &lt;http://localhost:8000&gt; to see your project dashboard.</code></pre>
<aside>
<p>It’s interesting to compare our Elm build system and the packaging of the Elm reactor with how this is done in Nix, which deals with both core issues (requiring a valid <code>versions.dat</code>, and the self-referential build) <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/elm/README.md">differently</a>: For one, it bundles a pre-generated <code>versions.dat</code> instead of generating it on the fly. Secondly, it builds an unpatched <code>elm tool</code> directly by providing a package database from the start.</p>
<p>I find that generating <code>versions.dat</code> ourselves makes packaging of Elm applications quite a bit simpler since we don’t need to use the <code>elm</code> tool ourselves, at the expense of duplicating the logic. Also, that code was fun to write!</p>
Regarding the second point, I’m quite convinced the two stage build process is an improvement, just because it’s so much simpler and easier to reason about. Although I’ll have to admit that to some extent it’s forced by Guix’ use of language-specific build systems: We don’t want to deal with building Elm code in a Haskell package.
</aside>
<p>That’s it for part 2. The code is available on branch <code>elm</code> of <a href="https://github.com/robx/guix/tree/elm">github.com/robx/guix</a>. The elm package itself in <a href="https://github.com/robx/guix/blob/elm/gnu/packages/elm.scm">gnu/packages/elm.scm</a>. At this point, none of the content of this article has made it to Guix upstream, because I haven’t submitted patches. While all of this works well enough, there’s some work to be done before I’d want to submit this upstream, which I currently don’t plan on doing:</p>
<ul>
<li>Improve some of the hacky parts, such as
<ul>
<li>unpacking source archives in the build system,</li>
<li>detecting Elm package inputs.</li>
</ul></li>
<li>Find a better way to specify the <code>elm make</code> command line, such as calling <code>make build</code> if there’s a <code>Makefile</code> around.</li>
<li>Generally clean up the code a bit.</li>
<li>Split the work into patches that satisfy the somewhat arcane commit message requirements of upstream.</li>
<li>Decide on how to package Elm package dependencies. I suspect keeping them application-local as we did here is not how the Guix project would prefer to handle this.</li>
<li>Update to Elm 0.19.1.</li>
</ul>
<p>I’d be thrilled if someone chose to take care of this, and would be happy to assist!</p>
<p>Tune in again for <a href="guix-elm-3.html">part 3</a>, where we’ll wrap this up by figuring out how to serve an Elm web application on Guix.</p>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Guix and Elm, part 1: Packaging the Elm compiler</title>
    <link href="https://vllmrt.net/spam/guix-elm-1.html" />
    <id>https://vllmrt.net/spam/guix-elm-1.html</id>
    <published>2019-11-27T00:00:00Z</published>
    <updated>2019-11-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>November 27, 2019</time>
        
        
    </section>
    <p>A few months ago, I converted a server I’m administering to run <a href="https://guix.gnu.org">Guix System</a>. I wouldn’t recommend you do the same at this point (the subject of a long and tragic story yet to be told), but I did learn a lot along the way; in particular, how to get an <a href="https://elm-lang.org">Elm</a> web app built and up and running, which I want to talk about here.</p>
<p>Aims:</p>
<ul>
<li>document the state of my Elm packaging work, so others can build on it</li>
<li>show how to bypass Elm’s “highly opinionated” packaging infrastructure</li>
<li>provide an introduction to guix packaging</li>
</ul>
<p>I’ve split this into a series of articles:</p>
<ol type="1">
<li>packaging the Elm compiler</li>
<li><a href="guix-elm-2.html">developing Guix infrastructure for building Elm apps, and using this to package the Elm reactor, and the full Elm tool</a></li>
<li><a href="guix-elm-3.html">deploying an Elm web application on Guix System</a></li>
</ol>
<p>In this first part, we’ll go over the Guix packaging of the Elm compiler proper, a Haskell project. This work has already made it to Guix upstream:</p>
<pre><code>$ guix package --show=elm-compiler
name: elm-compiler
version: 0.19.0
outputs: out
systems: x86_64-linux i686-linux
dependencies: ghc-ansi-terminal@0.8.0.4 ghc-ansi-wl-pprint@0.6.8.2 ghc-edit-distance@0.2.2.1
+ ghc-file-embed@0.0.10.1 ghc-http-client-tls@0.3.5.3 ghc-http-client@0.5.13.1 ghc-http-types@0.12.3
+ ghc-http@4000.3.12 ghc-language-glsl@0.3.0 ghc-logict@0.6.0.2 ghc-network@2.6.3.6
+ ghc-raw-strings-qq@1.1 ghc-scientific@0.3.6.2 ghc-sha@1.6.4.4 ghc-snap-core@1.0.3.2
+ ghc-snap-server@1.1.0.0 ghc-unordered-containers@0.2.9.0 ghc-utf8-string@1.0.1.1 ghc-vector@0.12.0.1
+ ghc-zip-archive@0.3.3
location: gnu/packages/elm.scm:40:2
homepage: https://elm-lang.org
license: Modified BSD
synopsis: The `elm&#39; command line interface, without {elm reactor  
description: This includes commands like `elm make&#39;, `elm repl&#39;, and many others for helping make Elm
+ developers happy and productive.</code></pre>
<h1 id="an-overview-of-elm-tooling">An overview of Elm tooling</h1>
<p>The <a href="https://guide.elm-lang.org/install/elm.html"><code>elm</code> tool</a> (sources at <a href="https://github.com/elm/compiler">github.com/elm/compiler</a>) is a command line program that provides a variety of subcommands related to building Elm applications. It’s written in Haskell, and our first step will be to build this tool with Guix (or enough of this tool to be able to run <code>elm make</code> successfully). The sources are at [github.com/elm</p>
<aside>
The packaging here is for the 0.19.0 version of Elm. In the meantime, a bugfix release 0.19.1 has been released.
</aside>
<aside>
To avoid some problems with the upstream 0.19.0 release, I initially based the packaging off the <a href="https://github.com/CurrySoftware/compiler">CurrySoftware fork</a>, which is where I found some of the patches that we’ll apply to the elm sources below.
</aside>
<p>It will be useful below to have a rough idea of how the <code>elm</code> tool works. Elm projects come in two forms: packages and applications. Packages are distributed via <a href="https://package.elm-lang.org">package.elm-lang.org</a>, and can be used as libraries from other packages and applications. Applications on the other hand are the “end product”, compiling to Javascript to be served to a web browser.</p>
<p>Both such projects are defined by a file <code>elm.json</code>. The <code>elm</code> tool is then run from a directory containing such a file. It provides a couple of commands; the relevant ones for us are:</p>
<dl>
<dt><code>elm make</code></dt>
<dd><p>Download package dependencies to <code>~/.elm</code> from package.elm-lang.org. Compile dependencies within <code>~/.elm</code> to an internal format. Compile Elm modules within <code>./elm-stuff</code> to the internal format. If this is an application, compile the internal format to Javascript.</p>
</dd>
<dt><code>elm reactor</code></dt>
<dd><p>This serves a web app to interactively debug your Elm application. It is itself implemented as an Elm application.</p>
</dd>
</dl>
<p>We’ll face issues with both of these: <code>elm make</code>’s all-in-one design is great for ease of use if you’re doing things the way they’re meant to be done. But when building in a sandboxed environment without internet access, we’ll need to trick it to believe it actually built its package database by talking to package.elm-lang.org. Then it’ll grudgingly fall back to an offline mode and work for us.</p>
<p>Concretely, we’ll construct a package database in <code>~/.elm/0.19.0/package/</code> by unpacking dependency sources there and generating a <code>versions.dat</code> database.</p>
<p>The issue with <code>elm reactor</code> isn’t with its use, but with its build: Since it is in Elm application itself, we need to have <code>elm make</code> (or its logic) available to build it. The clean way to do this is with a two-stage build, where we first build the Elm compiler, then use it to build the Elm reactor. Which is all good, except the upstream build solves this is a different and rather hacky way: It calls out to itself via Template Haskell, generating the web application Javascript during the build of the <code>elm</code> tool.</p>
<p>This one we’ll address by tearing the build apart: In a first stage, we’ll patch out the reactor and build a version of the <code>elm</code> tool that primarily supports <code>elm make</code>. In a second stage we’ll re-enable the reactor, providing Javascript files built using the first stage <code>elm make</code> tool.</p>
<aside>
Nix deals with both of these issues in a different way. See <a href="guix-elm-2.html">part 2</a> for a brief comparison.
</aside>
<h1 id="packaging-the-elm-compiler-minus-reactor">Packaging the elm compiler (minus reactor)</h1>
<p>The steps we’ll follow to package <code>elm make</code> are:</p>
<ol type="1">
<li>make sure the Haskell project builds with stack and the right LTS version</li>
<li>generate a package definition using <code>guix import hackage -s &lt; elm.cabal</code></li>
<li>import unpackaged Haskell dependencies</li>
<li>replace the source field to refer to the github release</li>
<li>apply patches</li>
</ol>
<p>We’ll go through this process explicitly below, not least to share the pain inherent in Guix packaging work.</p>
<p>The first step is easy enough. I found things built fine with a GHC 8.4 stackage release after applying the patch <a href="http://git.savannah.gnu.org/cgit/guix.git/plain/gnu/packages/patches/elm-compiler-relax-glsl-bound.patch">elm-compiler-relax-glsl-bound.patch</a> to relax version bounds.</p>
<p><code>guix import hackage</code> converts a cabal file into an expression of the form</p>
<pre><code>(package
  (name &quot;ghc-elm&quot;)
  (version &quot;0.19.0&quot;)
  (source
    (origin
      (method url-fetch)
      (uri (string-append
             &quot;https://hackage.haskell.org/package/elm/elm-&quot;
             version
             &quot;.tar.gz&quot;))
      (sha256
        (base32 &quot;failed to download tar archive&quot;))))
  (build-system haskell-build-system)
  (inputs
   `((&quot;ghc-ansi-terminal&quot; ,ghc-ansi-terminal)
     ...
     (&quot;ghc-zip-archive&quot; ,ghc-zip-archive)))
  (home-page &quot;https://elm-lang.org&quot;)
  (synopsis &quot;The `elm` command line interface&quot;)
  (description
   &quot;This includes commands like `elm make`, `elm repl`, and many others
for helping make Elm developers happy and productive.&quot;)
  (license bsd-3))</code></pre>
<p>This is a <a href="https://www.gnu.org/software/guile/manual/html_node/Record-Overview.html">scheme record</a>, with a number of named fields. The important ones are</p>
<dl>
<dt><code>source</code></dt>
<dd><p>This declares the package source archive.</p>
</dd>
<dt><code>inputs</code></dt>
<dd><p>This declares a list of dependencies. Typically, those are other packages.</p>
</dd>
<dt><code>build-system</code></dt>
<dd><p>This declares the build system that’s used. It’s pretty much up to the build system to define what the source and input fields actually are.</p>
</dd>
</dl>
<p>The dependencies in <code>inputs</code> are given as an association list of pairs <code>("package-name" ,package)</code>, where the name appears to be mostly irrelevant, while the package itself is a package record like we’re defining.</p>
<aside>
<p>Not knowing Scheme well before, I thought the comma was part of tuple syntax. Instead, it’s part of Scheme syntax for defining data that’s a mix of literal and evaluated data: <a href="https://www.gnu.org/software/guile/manual/html_node/Expression-Syntax.html#index-quasiquote">quasiquote</a>.</p>
When starting out with Guix, it’s tempting (and mostly fine) to do things by copy-and-pasting existing package definitions, but what with the sorry state of Guile error messages, there’s really no way around learning the language.
</aside>
<p>Let’s try to build this package definition: We’ll write it to a file called <code>elm.scm</code>, and call <code>guix build</code>:</p>
<pre><code>$ guix build -f elm.scm
ice-9/eval.scm:223:20: In procedure proc:
error: package: unbound variable
hint: Did you forget `(use-modules (guix packages))&#39;?</code></pre>
<p>Indeed, putting the hinted line at the top of the file helps.</p>
<aside>
The Guile module <code>(guix packages)</code> is defined in <code>guix/packages.scm</code> within the <a href="http://git.savannah.gnu.org/cgit/guix.git">guix</a> git repository. Generally, the guix tooling itself and packaging infrastructure is defined within <code>guix/</code>, while the packages themselves are defined under <code>gnu/</code>.
</aside>
<p>The next failure relates to the broken source field:</p>
<pre><code>$ guix build -f elm.scm
guix build: error: exception thrown: #&lt;condition &amp;invalid-base32-character [character: #\e string: &quot;failed to download tar archive&quot;] 29c9f00&gt;</code></pre>
<p>Unsurprisingly, <code>"failed to download tar archive"</code> isn’t a valid base32 hash. This happened because <code>elm</code> isn’t actually published on <a href="https://hackage.haskell.org">Hackage</a>, so <code>guix import</code> failed to download the source archive and compute a hash. To fix this, we edit the file to refer to a correct URI for the elm compiler sources, put in some arbitray valid hash copied from another package definition, and eventually fix the hash to the correct version.</p>
<pre><code>$ guix build -f elm.scm
ice-9/eval.scm:223:20: In procedure proc:
error: url-fetch: unbound variable
hint: Did you forget `(use-modules (guix build download))&#39;?</code></pre>
<p>Well, not “forget” as such, but indeed: adding the import gets us further.</p>
<pre><code>$ guix build -f elm.scm
ice-9/eval.scm:223:20: In procedure proc:
error: haskell-build-system: unbound variable
hint: Did you forget a `use-modules&#39; form?</code></pre>
<p>Yes, we also need <code>(use-modules (guix build-system haskell))</code>.</p>
<pre><code>$ guix build -f elm.scm
ice-9/eval.scm:223:20: In procedure proc:
error: bsd-3: unbound variable
hint: Did you forget `(use-modules (guix licenses))&#39;?</code></pre>
<p>Oh no. We did.</p>
<pre><code>$ guix build -f elm.scm
/home/rob/blog-test/elm.scm:17:3: In procedure inputs:
error: ghc-ansi-terminal: unbound variable
hint: Did you forget a `use-modules&#39; form?</code></pre>
<p>Oh, our dependencies aren’t yet imported. We can find this one:</p>
<pre><code>$ guix search ghc-ansi-terminal
name: ghc-ansi-terminal
version: 0.8.0.4
outputs: out
systems: x86_64-linux i686-linux
dependencies: ghc-colour@2.3.4
location: gnu/packages/haskell-xyz.scm:288:2
homepage: https://github.com/feuerbach/ansi-terminal
license: Modified BSD
synopsis: ANSI terminal support for Haskell  
description: This package provides ANSI terminal support for Haskell.  It allows cursor movement, screen clearing, color
+ output showing or hiding the cursor, and changing the title.
relevance: 20</code></pre>
<p>It’s defined in the module <code>(gnu packages haskell-xyz)</code>, so we’ll add an import for that. There’s a few more similar missing imports, which we fix by also importing <code>(gnu packages haskell-check)</code> and <code>(gnu packages haskell-web)</code>.</p>
<aside>
The Elm dependencies have by now all been packaged, but usually at this point you’d expect to find a few libraries that are still missing. Then we’d have to package those first. <code>guix import</code> has a recursive mode that can help with this.
</aside>
<pre><code>$ guix build -f elm.scm
Backtrace:
In guix/store.scm:
   623:10 19 (call-with-store _)
In guix/scripts/build.scm:
   914:26 18 (_ #&lt;store-connection 256.99 e32ae0&gt;)
In ice-9/boot-9.scm:
    829:9 17 (catch _ _ #&lt;procedure 1bf1800 at ice-9/boot-9.scm:104…&gt; …)
In guix/ui.scm:
    415:6 16 (_)
In guix/scripts/build.scm:
    879:5 15 (_)
In srfi/srfi-1.scm:
   679:15 14 (append-map _ _ . _)
   592:17 13 (map1 (&quot;x86_64-linux&quot;))
   679:15 12 (append-map _ _ . _)
   592:17 11 (map1 (#&lt;package elm@0.19.0 /home/rob/blog-test/elm.sc…&gt;))
In guix/scripts/build.scm:
   840:18 10 (_ _)
In guix/packages.scm:
   936:16  9 (cache! #&lt;weak-table 358/443&gt; #&lt;package elm@0.19.0 /ho…&gt; …)
  1255:22  8 (thunk)
  1188:25  7 (bag-&gt;derivation #&lt;store-connection 256.99 e32ae0&gt; #&lt;&lt;…&gt; …)
In srfi/srfi-1.scm:
   592:29  6 (map1 ((&quot;haskell&quot; #&lt;package ghc@8.4.3 gnu/packages…&gt;) …))
   592:17  5 (map1 ((&quot;source&quot; #&lt;origin &quot;https://github.com/elm/…&gt;) …))
In ice-9/boot-9.scm:
    829:9  4 (catch srfi-34 #&lt;procedure 3743870 at guix/packages.sc…&gt; …)
In guix/packages.scm:
  1003:18  3 (_)
In guix/store.scm:
  1803:24  2 (run-with-store #&lt;store-connection 256.99 e32ae0&gt; _ # _ …)
  1673:13  1 (_ _)
In guix/build/download.scm:
    741:0  0 (url-fetch _ _ #:timeout _ #:verify-certificate? _ # _ # …)

guix/build/download.scm:741:0: In procedure url-fetch:
Invalid keyword: #vu8(73 77 243 55 36 34 67 7 214 226 180 208 179 66 68 140 201 39 144 20 131 56 78 228 248 207 238 44 179 142 153 60)</code></pre>
<p>Oops. I’ve never seen this error before going through these steps again while writing the article. It <a href="https://lists.gnu.org/archive/html/guix-devel/2019-11/msg00332.html">turns out</a> that the helpful hint to import <code>(guix build download)</code> was misleading: We want to import the <code>url-fetch</code> from <code>(guix download)</code> instead.</p>
<pre><code>$ guix build -f elm.scm
[...]
downloading from https://github.com/elm/compiler/archive/0.19.0.tar.gz...
 0.19.0.tar.gz                                                                               608KiB/s 00:01 | 439KiB transferred
sha256 hash mismatch for /gnu/store/pcxygjzvmals9yramliz2bzznz1lh9i1-elm-0.19.0.tar.gz:
  expected hash: 1111111111111111111111111111111111111111111111111111
  actual hash:   0g4risrjrvngz3j4wf432j82gjcc8i1b7l5lwbb0fhr24hvz6ka9
hash mismatch for store item &#39;/gnu/store/pcxygjzvmals9yramliz2bzznz1lh9i1-elm-0.19.0.tar.gz&#39;
[...]</code></pre>
<p>Progress! We copy and paste the actual hash into <code>elm.scm</code>, and we’re actually trying to build. Though as expected, we run into trouble in the Haskell configure phase:</p>
<pre><code>$ guix build -f elm.scm
[...]
starting phase `configure&#39;
running &quot;runhaskell Setup.hs&quot; with command &quot;configure&quot; [...]
[...]
Configuring elm-0.19.0...
Setup.hs: Encountered missing dependencies:
language-glsl &gt;=0.0.2 &amp;&amp; &lt;0.3
[...]</code></pre>
<p>This is where we need to apply the patch <code>elm-compiler-relax-glsl-bound.patch</code>. We store it in the current directory, and add it to the source definition:</p>
<pre><code>  (source
    (origin
      (method url-fetch)
      (file-name &quot;elm-0.19.0.tar.gz&quot;)
      (uri &quot;https://github.com/elm/compiler/archive/0.19.0.tar.gz&quot;)
      (sha256
        (base32 &quot;0g4risrjrvngz3j4wf432j82gjcc8i1b7l5lwbb0fhr24hvz6ka9&quot;))
      (patches
       `(&quot;elm-compiler-relax-glsl-bound.patch&quot;))))</code></pre>
<pre><code>$ guix build -f elm.scm
[...]
ui/terminal/src/Develop/StaticFiles.hs:92:3: error:
    • Exception when trying to run compile-time code:
        /homeless-shelter: createDirectory: permission denied (Permission denied)
      Code: bsToExp =&lt;&lt; runIO Build.compile
    • In the untyped splice: $(bsToExp =&lt;&lt; runIO Build.compile)
   |
92 |   $(bsToExp =&lt;&lt; runIO Build.compile)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[...]</code></pre>
<p>Finally, we run into trouble with the convoluted Elm build: It’s trying to run the compiler itself while building, which tries to write to <code>$HOME</code>, which is read-only inside the guix sandbox. (We could get around this by providing a writable home directory, but then we’d fail soon after when it tries to access the network.)</p>
<p>We fix this by adding another patch, <a href="http://git.savannah.gnu.org/cgit/guix.git/plain/gnu/packages/patches/elm-compiler-disable-reactor.patch">elm-compiler-disable-reactor.patch</a>.</p>
<pre><code>$ guix build -f elm.scm
[...]
successfully built /gnu/store/8xn1irs377mk6n17bcrxr293qpzr6224-ghc-elm-0.19.0.drv
/gnu/store/542im7drgr0p37ymaiqkh31k5ff4ghaj-ghc-elm-0.19.0
$ /gnu/store/542im7drgr0p37ymaiqkh31k5ff4ghaj-ghc-elm-0.19.0/bin/elm
Hi, thank you for trying out Elm 0.19.0. I, Evan, hope you like it!
[...]</code></pre>
<p>Success! Wrapping this up as a package for Guix upstream requires a little bit more work:</p>
<ul>
<li>Bind the package definition to a name, and place it in a module within the <code>(gnu packages)</code> hierarchy.</li>
<li>Move the patches to <code>gnu/packages/patches/</code>, and add the files to the list in <code>gnu/local.mk</code>.</li>
<li>Rewrite the <code>guix import</code>-generated synopsis and description to fit the Guix style and markup format.</li>
</ul>
<p>You can look at the complete patch <a href="http://git.savannah.gnu.org/cgit/guix.git/commit/?id=c902458863d1d341ffd74970b75e69c2bb848183">in the guix repository</a>.</p>
<p>In the <a href="guix-elm-2.html">next article</a>, we’ll see how to use the Elm compiler within Guix to package Elm applications.</p>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell, Hakyll and Github Actions</title>
    <link href="https://vllmrt.net/spam/hakyll-github-actions-pages.html" />
    <id>https://vllmrt.net/spam/hakyll-github-actions-pages.html</id>
    <published>2019-11-13T00:00:00Z</published>
    <updated>2019-11-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>November 13, 2019</time>
        
        
    </section>
    <p>This is a short write-up on my current set-up for deploying this site. It covers:</p>
<ul>
<li>building Haskell projects with Github Actions, including caching</li>
<li>generating and deploying a static site via Github Actions</li>
<li>a bit of a review of Github Actions</li>
</ul>
<h1 id="the-manual-workflow">The manual workflow</h1>
<p>The site is generated using the <a href="https://jaspervdj.be/hakyll/">Hakyll</a> static site generator. Using it involves writing a small Haskell program <code>site</code> that calls out to the Hakyll libraries to build the website.</p>
<p>This program and the rest of the website sources live in one repository, and are deployed to Github Pages by pushing to a second repository, <a href="https://github.com/robx/robx.github.io">robx/robx.github.io</a>. The actual source repository is private, but you can checkout a snapshot at <a href="https://github.com/robx/site-demo">robx/site-demo</a>.</p>
<p>Updating the site then takes four steps:</p>
<ol start="0" type="1">
<li>edit some website source files</li>
<li>build the <code>site</code> executable</li>
<li>run <code>site</code> to generate the website content</li>
<li>commit and push the updated website to the destination repository</li>
</ol>
<p>Doing this manually, we would build the executable using <code>cabal build</code>, then build the site using <code>cabal exec site build</code>, and finally do something along the following lines to deploy:</p>
<pre><code>$ cd /src/robx/robx.github.io
$ rm -r * &amp;&amp; cp -r /src/robx/site/_site/* .
$ git add -A &amp;&amp; git commit -m &quot;update website&quot; &amp;&amp; git push</code></pre>
<h1 id="the-automatic-workflow">The automatic workflow</h1>
<p>Since doing this by hand is too much work and a bit error prone, let’s automate it using Github Actions. To do this, we define a workflow using a YAML file <code>build-deploy.yml</code> that lives in <code>.github/workflows/</code>. You can view the full <a href="https://github.com/robx/site-demo/blob/master/.github/workflows/build-deploy.yml">workflow file</a>, or check the (messy) <a href="https://github.com/robx/site-demo/actions">run history</a> at the demo repository. Below, we’ll go through that file chunk by chunk.</p>
<section>
<p>Our workflow gets a name, is set up to execute on push events, and has one job with id <code>build</code>.</p>
<pre><code>name: Build and deploy to github pages
on: push

jobs:
  build-deploy:</code></pre>
</section>
<section>
<p>Now comes the body of our <code>build-deploy</code> job. It gets a name as well as a base virtual environment. We also set some variables, since we’ll need to refer to the tool versions twice later on.</p>
<pre><code>    name: Build and deploy
    runs-on: ubuntu-latest
    env:
      GHC_VERSION: &#39;8.6.5&#39;
      CABAL_VERSION: &#39;3.0&#39;</code></pre>
<aside>
These lines define environment variables that are available in commands that we run from this job, although we don’t use them as such. Additionally, they are stored in the <code>env</code> “context”, and thus available within the workflow below. Note that the <code>env</code> context does <em>not</em> include environment variables beyond those defined within the workflow.
</aside>
</section>
<section>
<p>Finally, we give a list of steps that the job should perform. First, we call out to a github-provided action that checks out the working tree corresponding to the event that triggered the workflow.</p>
<pre><code>    steps:
      - uses: actions/checkout@master</code></pre>
<aside>
There are a number of packaged workflow components, available either from GitHub in the <a href="https://github.com/actions/">actions</a> organization, or from others via the <a href="https://github.com/marketplace?type=actions">marketplace</a>. The <code>checkout</code> action is defined in the repository <a href="https://github.com/actions/checkout">actions/checkout</a>.
</aside>
</section>
<section>
<p>Next, we call out to an action to install a Haskell toolchain. We specify versions for GHC and Cabal, referring to the variables using an adhoc expression language.</p>
<pre><code>      - uses: actions/setup-haskell@v1
        with:
          ghc-version: ${{env.GHC_VERSION}}
          cabal-version: ${{env.CABAL_VERSION}}</code></pre>
</section>
<section>
<p>Building Haskell projects tends to take too much time: A fresh build of Hakyll on the Github Actions infrastructure takes around 30 minutes. So we’ll cache the compiled dependencies. We’ll be using Cabal’s Nix-style builds here, which store artifacts in <code>$HOME/.cabal/store</code>.</p>
<p>The way caching works, we need to provide a cache key that includes full dependency version information. For simplicity, we’ll assume the existence of a Cabal version locking file <code>cabal.project.freeze</code>; see below for another approach.</p>
<pre><code>      - name: &#39;Run actions/cache@v1: cache cabal store&#39;
        uses: actions/cache@v1
        with:
          path: ~/.cabal/store
          key: cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-${{ hashFiles(&#39;cabal.project.freeze&#39;) }}
          restore-keys: |
            cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-
            cabal-store-${{ runner.OS }}-</code></pre>
When run, this action will restore any existing archive under the given key, falling back to any of the alternate keys listed under <code>restore-keys</code>. In addition, the action has a “post action”, which will save an archive at the end of a successful run.
</section>
<section>
<p>Now we’re ready to execute a couple of commands to build the Haskell project and generate the site:</p>
<pre><code>      - run: cabal update
      - run: cabal build --only-dependencies
      - run: cabal build
      - run: cabal exec site build</code></pre>
<ul>
<li><code>cabal update</code> fetches the package database from hackage. (This package database might also be cached between runs, but at ~30s I didn’t bother so far.)</li>
<li><code>cabal build --only-dependencies</code> builds the dependencies only. It’s useful to split this from the project build itself below:
<ol type="1">
<li>While getting things to work, we can disable later steps in order to get the dependency cache ready, making iterating on the later steps a lot faster.</li>
<li>We can easily distinguish between problems with the project itself and with the packaging infrastructure.</li>
</ol></li>
<li><code>cabal build</code> builds the Hakyll <code>site</code> executable itself.</li>
<li><code>cabal exec site build</code> calls this executable, generating the website.</li>
</ul>
</section>
<section>
<p>Finally, we check the commit the updated version of the site to the github pages repository, using one of a multitude of third party actions that deal with this task. This action in particular has the advantage of supporting ssh deploy keys, while most other actions appear to require a (far more powerful) personal access token to interact with a different repository.</p>
<pre><code>      - name: &#39;Run peaceiris/actions-gh-pages@v2.5.0: deploy to github pages&#39;
        uses: peaceiris/actions-gh-pages@v2.5.0
        env:
          ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }}
          PUBLISH_BRANCH: master
          PUBLISH_DIR: _site
          EXTERNAL_REPOSITORY: robx/robx.github.io
        if: github.ref == &#39;refs/heads/master&#39;</code></pre>
<p>The <code>if:</code> condition ensures that this step is only run on pushes to master.</p>
<aside>
<p>It’s nice to have the rest of the workflow execute also on other branches, to be able to debug it easily. If we didn’t want that, we might instead have limited the workflow to run only on pushes to master by filtering in the top-level <code>on:</code> field, as follows.</p>
<pre><code>on:
  push:
    branches:
      - master</code></pre>
</aside>
To configure the <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys">deploy key</a>, generate an ssh key-pair, add the public key to the github pages repository as a deploy key, and store the private key in the source repository secrets under the key <code>ACTIONS_DEPLOY_KEY</code>. The <a href="https://github.com/peaceiris/actions-gh-pages#1-add-ssh-deploy-key">README</a> of this action has detailed instructions.
</section>
<h1 id="some-extra-snippets">Some extra snippets</h1>
<h2 id="debugging">Debugging</h2>
<p>The following step is useful to have in there to aid in debugging a workflow. It stores a number of contexts to <code>env</code>, which is enough to be able to inspect them in the web interface.</p>
<pre><code>- name: Dump contexts
  env:
    CTX_GITHUB: ${{ toJson(github) }}
    CTX_STEPS: ${{ toJson(steps) }}
    CTX_ENV: ${{ toJson(env) }}
  run: true</code></pre>
<h2 id="caching-with-cabal.project.freeze">Caching with cabal.project.freeze</h2>
<p>To get reliable caching with <code>cabal</code> regardless of the existence of a freeze file, you can reorder things as follows:</p>
<pre><code>- run: cabal update
- run: &#39;[ -e cabal.project.freeze ] || cabal freeze&#39;
- name: &#39;Run actions/cache@v1: cache cabal store&#39;
  uses: actions/cache@v1
  with:
    path: ~/.cabal/store
    key: cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-${{ hashFiles(&#39;cabal.project.freeze&#39;) }}
    restore-keys: |
      cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-
      cabal-store-${{ runner.OS }}-
- run: cabal build --only-dependencies</code></pre>
<p>This generates an up-to-date freeze file and uses it to compute the cache key.</p>
<p>It’s necessary to get the version information into the cache key instead of just e.g. hashing the cabal file itself: Otherwise, the cache key will be constant across runs whence the cache won’t be updated, even as the cache gets outdated in relation to upstream.</p>
<aside>
As dependencies get updated, the cache will keep growing. This seems to be a general problem with dependency caching that I don’t see a good way around.
</aside>
<h1 id="github-actions-pain-points-open-ends">Github Actions pain points, open ends</h1>
<p>This works and I’m happy enough with it. Getting to this state was quite painful though, and I’m not thrilled with Github Actions in their current state. Some random thoughts:</p>
<ul>
<li><p>Storing the GHC version in <code>env</code>, and referencing this later, seems needlessly verbose. I’d prefer to be able to reference the inputs to <code>actions/setup-haskell</code> directly.</p></li>
<li><p>Generally, the variable handling is messy. I spent hours trying to get the documented HOME environment variable into the cache path, before finding out that <code>~</code> works. It turns out it <em>is</em> possible to get environment variables to the expression level, by doing the following (yikes!):</p>
<pre><code>- id: get-home
  run: |
    echo &quot;::set-output name=home::$HOME&quot;
- uses: actions/cache@v1
  with:
    path: ${{ steps.get-home.outputs.home }}/.cabal/store</code></pre></li>
<li><p>The whole thing has a very ad hoc feel to it, with lack of overall design. The language is strange – why bring Javascript-like property and index syntax into the <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions">expression syntax</a>? What’s with the weird type coercion rules? In general, it feels like a bit more distance to the Javascript sphere might have been beneficial.</p></li>
<li><p>I have doubts with respect to the trust model and third-party actions. I’m happy to trust the Github provided actions with my secrets, and I’m happy to trust e.g. <code>peaceiris/actions-gh-pages@v2.5.0</code> with my deploy key after reviewing it. But I don’t see any guarantees that it won’t be replaced by a malicious version.</p></li>
<li><p>It’s easy to make typos in YAML field names that typically won’t give obvious errors. In general, getting to a working workflow is too much trial and error, due to a combination of a confused design and inaccurate documentation. The system seems best learnt by copying and modifying existing scripts.</p></li>
<li><p>I like the option of using and providing third-party actions. However I’m not so convinced right now by the design here. I don’t see a (straightforward) way to bundle up <code>actions/setup-haskell</code> and <code>actions/cache</code> to provide a one-stop Haskell setup. And neither dropping to the Docker level nor using NodeJS (why?) are appealing.</p></li>
</ul>
<p>There are also some open ends on the Haskell side of things.</p>
<ul>
<li><p>I’m building the site with <code>stack</code> locally, instead of <code>cabal</code>. I went with <code>cabal</code> here because that’s what <code>actions/setup-haskell</code> provides, but would prefer to set this up with <code>stack</code>.</p></li>
<li><p>I’m using a forked version of Hakyll via <a href="https://github.com/robx/site-demo/blob/master/cabal.project">cabal.project</a>, and that is getting rebuilt every time. It would be nice to figure out how to cache this.</p></li>
</ul>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Solving a word puzzle with Mercury</title>
    <link href="https://vllmrt.net/spam/solving-a-puzzle-with-mercury.html" />
    <id>https://vllmrt.net/spam/solving-a-puzzle-with-mercury.html</id>
    <published>2014-02-15T19:36:21Z</published>
    <updated>2014-02-15T19:36:21Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>February 15, 2014</time>
        
        
            <span class="orig">
                previously published at <a href="http://maybepuzzles.com/2014/02/15/an-excursion-into-logic-programming-solving-a-word-puzzle-with-mercury/">maybepuzzles</a>
            </span>
        
    </section>
    <p>I recently had the need to check a couple of puzzles that were geared towards intuitive solving, and consequently tricky to prove correct by hand. Luckily enough, Nikolai Beluhov posted an excellent <a href="https://web.archive.org/web/20140215022411/http://nbpuzzles.wordpress.com/2014/02/05/curve-data-solver-and-constructor/">Curve Data solver</a> at just the right moment, allowing me to fix one broken puzzle. For the other, I took the chance to finally play around with <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>. Prolog is likely the best-known language from this domain, but I went with <a href="http://www.mercurylang.org">Mercury</a>, which is quite close to Prolog, but adds a couple of nice things like a static type system.</p>
<p>The project was quite successful: It solved the problem and was a lot of fun. Unfortunately, the solver turned out a little too complex to fit into a blog post, largely due to the complexity of the puzzle type. Thus, I decided to break it down to a way simpler (simplistic, even) puzzle, with the option of presenting the full solver in a second post.</p>
<h3 id="a-word-placement-puzzle">A word placement puzzle</h3>
<p><strong>Rules</strong> Write the word “PUZZLE” in the grid by placing letters in some empty cells. The word may read in any of the eight horizontal, vertical or diagonal directions.</p>
<figure>
<img src="/images/wordplace.png" width="305" alt="" /><figcaption>The puzzle</figcaption>
</figure>
<p>Below, we’ll develop the solver step by step.</p>
<h2 id="building-the-solver">Building the solver</h2>
<p>A brief disclaimer before we get started: I learnt all that I know about Mercury and logic programming from this one project, so it’s quite likely that I get some things wrong. If I come across as falsely authoritative below, I apologize. Any corrections much appreciated, as well as suggestions that would make the code more idiomatic.</p>
<p>My main sources were the excellent <a href="http://www.mercurylang.org/documentation/papers/book.pdf">Mercury tutorial</a> and the <a href="http://www.mercurylang.org/information/doc-release/mercury_library/index.html">library documentation</a>. There’s also some useful examples in the source distribution, which I found a little late. To run this at home, it looks like you have to compile Mercury from source, though Linux users may be lucky? Fortunately, it turned out to be quite straightforward to build.</p>
<h3 id="the-header">The header</h3>
<p>If you paste all the code from this post into a file <code>wordplace.m</code> (or download it from <a href="https://github.com/robx/puzzles/raw/master/words/wordplace.m">github</a>), you can compile it with <code>mmc --make wordplace</code>, then run <code>./wordplace</code>.</p>
<p>We start with a standard header section, which states that all we’re exporting is the <code>main</code> predicate, and which imports a bunch of modules from the <a href="http://www.mercurylang.org/information/doc-release/mercury_library/index.html">standard library</a>.</p>
<pre><code>:- module wordplace.

:- interface.

:- import_module io.

:- pred main(io::di, io::uo) is det.

:- implementation.

:- import_module char.
:- import_module int.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module solutions.
:- import_module string.</code></pre>
<h3 id="types-and-data">Types and data</h3>
<p>Next, we define some types in order to be able to express the puzzle. We’re working with a two-dimensional square grid of characters; the puzzle is specified by the size of the grid, by the hints (characters at points), and the word we’re trying to place.</p>
<p>There’s no particular reason I went with named fields for <code>size</code> and a plain pair of integers for <code>point</code> here. They’re mostly the same, for our purposes at least. (There’s also an explicit <code>pair</code> type in the standard library (<a href="http://www.mercurylang.org/information/doc-release/mercury_library/pair.html">pair</a>), don’t ask me why.) For <code>word</code>, we might have chosen <code>string</code> instead, but lists of characters seem easier to work with.</p>
<p><code>size</code> and <code>puzzle</code> are both new types, with the difference that the fields are named for <code>size</code>, the others are just new type names. There’s no need for the the left “<code>puzzle</code>” (the type name) to agree with the right “<code>puzzle</code>” (the data constructor).</p>
<pre><code>:- type hint == {point, char}.
:- type word == list(char).
:- type size ---&gt; size(width :: int, height :: int).
:- type puzzle ---&gt; puzzle(size, word, list(hint)).</code></pre>
<p>Our sample puzzle is then simply a constant function with no arguments, with value <code>P</code> of type <code>puzzle</code> constructed from its parts.</p>
<pre><code>:- func sample = puzzle.
sample = P :-
    S = size(7, 7),
    W = string.to_char_list(&quot;PUZZLE&quot;),
    Hs = [ {{1, 6}, &#39;P&#39;}, {{2, 6}, &#39;P&#39;}, {{3, 6}, &#39;U&#39;}
         , {{4, 5}, &#39;U&#39;}, {{6, 5}, &#39;P&#39;}
         , {{1, 4}, &#39;E&#39;}, {{2, 4}, &#39;Z&#39;}, {{4, 4}, &#39;E&#39;}, {{6, 4}, &#39;Z&#39;}
         , {{0, 3}, &#39;L&#39;}, {{3, 3}, &#39;Z&#39;}, {{6, 3}, &#39;L&#39;}
         , {{0, 2}, &#39;P&#39;}, {{2, 2}, &#39;U&#39;}, {{4, 2}, &#39;Z&#39;}, {{5, 2}, &#39;E&#39;}
         , {{0, 1}, &#39;U&#39;}, {{2, 1}, &#39;Z&#39;}
         , {{3, 0}, &#39;L&#39;}, {{4, 0}, &#39;U&#39;}, {{5, 0}, &#39;P&#39;}
         ],
    P = puzzle(S, W, Hs).</code></pre>
<p>We’ll also need some way to represent the character grid. Here, we’ll go with a <a href="http://www.mercurylang.org/information/doc-release/mercury_library/map.html">map</a> of <code>point</code> to <code>char</code>. A cell is empty if the corresponding point is not in the map, otherwise the character in that cell is the mapped value. We also include the size of the grid, and agree to index the cells with pairs <code>{0..width-1,0..height-1}</code>.</p>
<pre><code>:- type grid ---&gt; grid(size :: size, map :: map(point, char)).</code></pre>
<h3 id="an-outline-and-main">An outline, and <code>main</code></h3>
<p>Now we’re ready to declare the core of our solver:</p>
<pre><code>:- pred solve(puzzle::in, grid::out) is nondet.</code></pre>
<p><code>solve(P, G)</code> states that the grid <code>G</code> is a solution of the puzzle <code>P</code>. Futhermore, we’re saying that we’ll give a definition of <code>solve</code> that allows determining such <code>G</code> given <code>P</code> (the <code>in</code> and <code>out</code> modes), and that for a given <code>P</code>, there may be 0 to many <code>G</code> (<code>nondet</code>).</p>
<p>The fun part will be implementing <code>solve</code>, but first let’s wrap it in a proper program. Our aim is simply to find and print all solutions to the puzzle. Printing is handled by a deterministic predicate <code>print_grids</code> (implementation deferred), which takes a list of grids, and transforms the state of the world (which has type <code>io</code>). Compare to the declaration of the <code>main</code> predicate in the header.</p>
<pre><code>:- pred print_grids(list(grid)::in, io::di, io::uo) is det.</code></pre>
<p>The <a href="http://www.mercurylang.org/information/doc-release/mercury_library/solutions.html">solutions</a> module provides some tools for getting at all results of a predicate. <code>solutions.solutions</code> in particular returns all outputs of a one-parameter predicate. Now we can define <code>main</code>:</p>
<pre><code>main(IO_in, IO_out) :-
    solutions(pred(G::out) is nondet :- solve(sample, G),
              Gs),
    print_grids(Gs, IO_in, IO_out).</code></pre>
<p>The first argument to <code>solutions</code> is an anonymous predicate that’s the partial application of <code>solve</code> to our sample puzzle.</p>
<p>This is probably a good point to think about how to think about that definition of <code>main</code>: We’re not saying to first compute the solutions, afterwards print the grids. Instead, we’re saying that the predicate <code>main</code> is the conjunction of the two statements, the comma should be read as “and”. We leave it to the compiler to actually do something with that definition.</p>
<p><code>main</code> transforms the state of the world from <code>IO_in</code> to <code>IO_out</code> if and only if <code>Gs</code> is the list of solutions to our puzzle, and printing the grids <code>Gs</code> transforms the world from <code>IO_in</code> to <code>IO_out</code>. Now running the program means finding out what <code>main</code> does to the state of the world, which means finding out what <code>print_grids</code> does, which depends on <code>Gs</code>. So <code>solutions</code> needs to be “called” first, before <code>print_grids</code> can be “called” on the results.</p>
<p>In particular, the order of the statements doesn’t matter, we might as well have placed that <code>print_grids</code> statement at the beginning. That said, it’s helpful to order definitions in a way that they can be evaluated top-to-bottom.</p>
<h3 id="solving-the-puzzle">Solving the puzzle</h3>
<p>We’ll let the grid do most of the work. First, let’s set it up properly, by setting the size and initializing the underlying map.</p>
<pre><code>:- pred init_grid(size::in, grid::out) is det.
init_grid(S, G) :-
    map.init(M),
    G = grid(S, M).</code></pre>
<p>Some bounds checking will be useful. Note that the following two predicates are in a sense the same: They both state that the point <code>P</code> is within the bounds given by <code>S</code>. But as defined below, <code>in_bounds</code> tests this property, while <code>nondet_in_bounds</code> generates points within the given bounds.</p>
<pre><code>:- pred in_bounds(size::in, point::in) is semidet.
in_bounds(S, {X, Y}) :-
    X &gt;= 0,
    Y &gt;= 0,
    X &lt; S^width,
    Y &lt; S^height.

:- pred nondet_in_bounds(size::in, point::out) is nondet.
nondet_in_bounds(S, {X, Y}) :-
    size(W, H) = S,
    int.nondet_int_in_range(0, W - 1, X),
    int.nondet_int_in_range(0, H - 1, Y).</code></pre>
<p>With this, we’re ready to define the fundamental grid operation, placing a character <code>C</code> at a point <code>P</code> in a grid <code>G</code>. This is semi-deterministic: If the position is out of bounds, or if there’s already a different character at that location, the character can’t be placed. Otherwise, the resulting grid is unique. In other words, there’s at most one result.</p>
<pre><code>:- pred place_char(point::in, char::in, grid::in, grid::out) is semidet.
place_char(P, C, Gin, Gout) :-
    grid(S, M) = Gin,
    in_bounds(S, P),
    map.search_insert(P, C, OldC, M, M1),
    (
        OldC = no
    ;
        OldC = yes(C)
    ),
    Gout = grid(S, M1).</code></pre>
<p>Line by line, we first deconstruct the input grid, then check that the point is in bounds. We rely on <a href="http://www.mercurylang.org/information/doc-release/mercury_library/map.html">map.search_insert</a> to handle the conditional map update. Its input parameters are the point <code>P</code>, the character <code>C</code>, and the original map <code>M</code>. Its output consists of <code>OldC</code> which has type <code>maybe(char)</code>, and the modified map <code>M1</code>. A <code>maybe(char)</code> is either nothing (<code>no</code>) or some character (<code>yes('a')</code>). Now <code>search_insert</code> does one of two things: If the map already contains <code>P</code> with value <code>D</code>, the map isn’t changed, and <code>OldC</code> is set to <code>yes(D)</code>. Otherwise, the element is inserted, and <code>OldC</code> is set to <code>no</code>.</p>
<p>Following the optional insert we see a disjunction: We say it’s fine if <code>OldC</code> is <code>no</code> (i.e., the cell was previously empty), or if <code>OldC</code> is <code>yes(C)</code> (i.e., the cell was previously occupied, but with the character we’re trying to place. The case that we’re deliberately omitting is <code>yes(D)</code> for some other character <code>D</code>: that’s a real collision.</p>
<p>Finally, we put <code>S</code> and the modified map <code>M1</code> back together to yield the result grid.</p>
<p>Building on this, we can define a couple of predicates to place more than one character at a time. First, a list of located characters (we could use <code>foldl</code> here instead of explicit recursion).</p>
<pre><code>:- pred place_chars(list({point, char}):: in, grid::in, grid::out) is semidet.
place_chars([], Gin, Gout) :-
    Gout = Gin.
place_chars([{P, C}|Xs], Gin, Gout) :-
    place_char(P, C, Gin, G1),
    place_chars(Xs, G1, Gout).</code></pre>
<p>Next, placing a <code>word</code> in a specified direction starting at a given point.</p>
<pre><code>:- type dir == {int, int}.

:- func move(dir, point) = point.
move({DX, DY}, {PX, PY}) = {PX + DX, PY + DY}.

:- pred place_word(point::in, dir::in, word::in,
                   grid::in, grid::out) is semidet.
place_word(_, _, [], Gin, Gout) :-
    Gin = Gout.
place_word(P, D, [C|Cs], Gin, Gout) :-
    place_char(P, C, Gin, G),
    P1 = move(D, P),
    place_word(P1, D, Cs, G, Gout).</code></pre>
<p>Or placing a <code>word</code> in an arbitrary direction at an arbitrary point:</p>
<pre><code>:- func dirs = list(dir).
dirs = [ {-1,-1}, {-1, 0}, {-1, 1}, { 0, 1}
       , { 1, 1}, { 1, 0}, { 1,-1}, { 0,-1}
       ].

:- pred place_word_any(word::in, grid::in, grid::out) is nondet.
place_word_any(W, Gin, Gout) :-
    grid(S, _) = Gin,
    nondet_in_bounds(S, P),
    list.member(D, dirs),
    place_word(P, D, W, Gin, Gout).</code></pre>
<p>Puzzle solved:</p>
<pre><code>solve(Pz, Gout) :-
    Pz = puzzle(S, W, Hs),
    init_grid(S, G0),
    place_chars(Hs, G0, G1),
    place_word_any(W, G1, Gout).</code></pre>
<h3 id="printing-the-solutions">Printing the solutions</h3>
<p>To finish off the program, we still need to implement <code>print_grids</code>. That’s below. <del>with some code that feels a little suboptimal. I’m sure it’s not necessary to define ranges of integers, and there must be a more elegant way to convert from a semi-deterministic predicate to a maybe type than going through lists. But it works.</del> <strong>Edit</strong> Improved version, thanks to Paul Bone.</p>
<p>By the way, the <code>!IO</code> is just magic syntax for stringing through a list of modifications, we might have used <code>!G</code> at some points above where we did the <code>Gin</code>, <code>G1</code>, <code>Gout</code> dance.</p>
<pre><code>:- func int_range(int) = list(int).
int_range(N) = (if N =&lt; 0 then [] else [N - 1|int_range(N - 1)]).

:- pred char_at(grid::in, point::in, char::out) is semidet.
char_at(G, P, C) :-
    C = map.search(G^map, P).

:- func show_char(grid, point) = char.
show_char(G, P) = C :-
    ( if char_at(G, P, CPrime) then
        C = CPrime
    else
        C = (&#39;.&#39;)
    ).

:- func show_line(grid, int) = string.
show_line(G, Y) =
    string.from_char_list(
        map(func(X) = show_char(G, {X, Y}),
            list.reverse(int_range(G^size^width)))
    ).

:- func show(grid) = list(string).
show(G) = map(func(Y) = show_line(G, Y), int_range(G^size^height)).

:- pred write_line(string::in, io::di, io::uo) is det.
write_line(L, !IO) :- io.format(&quot;%s\n&quot;, [s(L)], !IO).

print_grids([], !IO).
print_grids([G|Gs], !IO) :-
    foldl(write_line, show(G), !IO),
    print_grids(Gs, !IO).</code></pre>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>
<entry>
    <title>Drawing puzzles with TikZ</title>
    <link href="https://vllmrt.net/spam/drawing-puzzles-with-tikz.html" />
    <id>https://vllmrt.net/spam/drawing-puzzles-with-tikz.html</id>
    <published>2014-02-05T19:26:48Z</published>
    <updated>2014-02-05T19:26:48Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>February  5, 2014</time>
        
        
            <span class="orig">
                previously published at <a href="https://maybepuzzles.com/2014/02/05/drawing-puzzles-with-tikz/">maybepuzzles</a>
            </span>
        
    </section>
    <p>There seems to be a lack of information out there when it comes to rendering puzzles. The most obvious approach is probably to use a vector graphics program such as <a href="http://inkscape.org">Inkscape</a>, but people also use spreadsheet software or write Postscript directly. I’ve recently started using the Haskell <a href="http://projects.haskell.org/diagrams/">Diagrams</a> framework (more on that in a future post), but for today, I want to share how to render pretty puzzles using TikZ via LaTeX.</p>
<p>Simplifying things a bit, <a href="http://en.wikipedia.org/wiki/PGF/TikZ">TikZ</a> is a vector graphics package for the <a href="http://en.wikipedia.org/wiki/LaTeX">LaTeX</a> document preparation system. If you want to follow along at home, install some TeX system, typically via your OS’ packaging system or from <a href="https://www.tug.org/texlive/">TeX Live</a>. We’ll be writing a text file <code>puzzle.tex</code>; running <code>pdflatex puzzle.tex</code> will yield <code>puzzle.pdf</code> if nothing goes wrong. Or use <a href="https://www.tug.org/texworks/">TeXworks</a>.</p>
<p>As an example, we’ll draw a small Slalomrundweg, see the <a href="http://www.logic-masters.de/Raetselportal/Raetsel/zeigen.php?id=00016Q">Rätselportal</a> for the rules. Here’s what it will look like:</p>
<figure>
<img src="/images/slalomrundweg.png" width="380" alt="" /><figcaption>Slalomrundweg</figcaption>
</figure>
<p>We’ll start with some boilerplate; it’s a good idea to keep the code below in a file <code>template.tex</code>:</p>
<pre><code>\documentclass{article}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage[tightpage,active]{preview}
\PreviewEnvironment{tikzpicture}

\begin{document}
\begin{tikzpicture}[scale=0.8]

% insert puzzle here

\end{tikzpicture}
\end{document}</code></pre>
<p>This sets up a basic LaTex document that consists of a single TikZ picture. We tell LaTeX to load TikZ, including the <code>arrows</code> library, and to produce an output file that contains just the <code>tikzpicture</code> we’re going to fill in below. Cropping the document to that picture is what the mysterious <code>preview</code> stuff is for. One thing to note is the option <code>scale</code> to the <code>tikzpicture</code> environment: The default unit is 1cm, so this makes our grid cells have size 8mm.</p>
<p>Let’s put in a grid:</p>
<pre><code>\draw[thin, black!50] (0,0) grid (6,6);
\draw[very thick] (0,0) rectangle (6,6);</code></pre>
<p>Pretty easy, right? Paste this inside the <code>tikzpicture</code> environment and render it, and you should see an empty grid. The edges might not be very nice because of how <code>preview</code> crops the document to the picture; we could fix this by setting a <code>PreviewBorder</code>, but instead we’ll just enlarge the picture size. This will also make the image stay centered once we add the arrows.</p>
<pre><code>\path (-1,-1) rectangle (7,7);</code></pre>
<p><code>\path</code> is like <code>\draw</code>, except that it doesn’t use a pen. Next, we’ll add the clues. To just put the letter <code>A</code> at the point (2,3), we’d use <code>\node at (2,3) {A};</code>, but we need a little more than that for our circled clues.</p>
<pre><code>\tikzstyle{clue} = [
    circle,
    draw,
    fill=white,
    inner sep=2pt,
    font=\sffamily\large
]

\foreach \x/\y/\c in {1/1/1, 1/5/1, 5/1/3, 5/5/4, 3/3/1}
    \node[clue] at (\x,\y) {\c};</code></pre>
<p>First we define the style of our clue nodes. This isn’t strictly necessary, it just means that when we write <code>\node[clue]</code>, the <code>clue</code> part is replaced by all the things in the earlier list. Those are:</p>
<dl>
<dt><code>circle</code></dt>
<dd><p>the outline of the node is a circle</p>
</dd>
<dt><code>draw</code></dt>
<dd><p>we want the outline to be drawn</p>
</dd>
<dt><code>fill=white</code></dt>
<dd><p>we fill the background in white, to cover the grid lines</p>
</dd>
<dt><code>inner sep=2pt</code></dt>
<dd><p>a margin between the text and the circle (the node is sized to accomodate the text, which might not really be what we want here…)</p>
</dd>
<dt><code>font=\sffamily\large</code></dt>
<dd><p>choose the text font and size</p>
</dd>
</dl>
<p>Then, we use <code>\foreach</code> to place the clues at the given coordinates.</p>
<p>Finally, let’s add the arrows for the solution code. There’s some tricky stuff here that’s required to get them to look just right.</p>
<pre><code>\tikzstyle{arr} = [
    -triangle 90,
    line width=0.4mm,
    postaction={draw, line width=0.1cm, shorten &gt;=0.1cm, -}
]
\draw[arr] (-0.7,3) -- (-0.2,3);
\draw[arr] (3,6.7) -- (3,6.2);</code></pre>
<p>That’s it! As a bonus, and at the risk of spoiling the puzzle, add the following. Best between drawing the grid and drawing the clues.</p>
<pre><code>\draw[ultra thick, black!70]
    (3,5) -- (1,3) -- (3,1) -- (5,3)
    (1,1) -- (2,2)    (1,5) -- (2,4)
    (4,0) -- (6,2)    (5,1) -- (6,0)
    (3,3) -- (6,6)    (4,6) -- (6,4);
\draw[ultra thick, red!70]
    (1,0) -- (2,1) -- (3,0) -- (6,3)
          -- (5,4) -- (3,2) -- (2,3)
          -- (4,5) -- (3,6) -- (2,5)
          -- (1,6) -- (0,5) -- (1,4)
          -- (0,3) -- (1,2) -- (0,1) -- (1,0);</code></pre>
    <footer>
    If you have comments or questions, write me at
    <span class="email">&lt;spam at this domain&gt;</span>.
    <br>
    More spam at <a href="/spam">/spam</a>.
    </footer>
</article>
]]></summary>
</entry>

</feed>
