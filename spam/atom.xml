<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>vllmrt.net/spam</title>
    <link href="https://vllmrt.net/spam/atom.xml" rel="self" />
    <link href="https://vllmrt.net" />
    <id>https://vllmrt.net/spam/atom.xml</id>
    <author>
        <name>Robert Vollmert</name>
        
    </author>
    <updated>2019-11-13T00:00:00Z</updated>
    <entry>
    <title>Haskell, Hakyll and Github Actions</title>
    <link href="https://vllmrt.net/spam/hakyll-github-actions-pages.html" />
    <id>https://vllmrt.net/spam/hakyll-github-actions-pages.html</id>
    <published>2019-11-13T00:00:00Z</published>
    <updated>2019-11-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>November 13, 2019</time>
        
        
    </section>
    <p>This is a short write-up on my current set-up for deploying this site. It covers:</p>
<ul>
<li>building Haskell projects with Github Actions, including caching</li>
<li>generating and deploying a static site via Github Actions</li>
<li>a bit of a review of Github Actions</li>
</ul>
<h1 id="the-manual-workflow">The manual workflow</h1>
<p>The site is generated using the <a href="https://jaspervdj.be/hakyll/">Hakyll</a> static site generator. Using it involves writing a small Haskell program <code>site</code> that calls out to the Hakyll libraries to build the website.</p>
<p>This program and the rest of the website sources live in one repository, and are deployed to Github Pages by pushing to a second repository, <a href="https://github.com/robx/robx.github.io">robx/robx.github.io</a>. The actual source repository is private, but you can checkout a snapshot at <a href="https://github.com/robx/site-demo">robx/site-demo</a>.</p>
<p>Updating the site then takes four steps:</p>
<ol start="0" type="1">
<li>edit some website source files</li>
<li>build the <code>site</code> executable</li>
<li>run <code>site</code> to generate the website content</li>
<li>commit and push the updated website to the destination repository</li>
</ol>
<p>Doing this manually, we would build the executable using <code>cabal build</code>, then build the site using <code>cabal exec site build</code>, and finally do something along the following lines to deploy:</p>
<pre><code>$ cd /src/robx/robx.github.io
$ rm -r * &amp;&amp; cp -r /src/robx/site/_site/* .
$ git add -A &amp;&amp; git commit -m &quot;update website&quot; &amp;&amp; git push</code></pre>
<h1 id="the-automatic-workflow">The automatic workflow</h1>
<p>Since doing this by hand is too much work and a bit error prone, let’s automate it using Github Actions. To do this, we define a workflow using a YAML file <code>build-deploy.yml</code> that lives in <code>.github/workflows/</code>. You can view the full <a href="https://github.com/robx/site-demo/blob/master/.github/workflows/build-deploy.yml">workflow file</a>, or check the (messy) <a href="https://github.com/robx/site-demo/actions">run history</a> at the demo repository. Below, we’ll go through that file chunk by chunk.</p>
<section>
<p>Our workflow gets a name, is set up to execute on push events, and has one job with id <code>build</code>.</p>
<pre><code>name: Build and deploy to github pages
on: push

jobs:
  build-deploy:</code></pre>
</section>
<section>
<p>Now comes the body of our <code>build-deploy</code> job. It gets a name as well as a base virtual environment. We also set some variables, since we’ll need to refer to the tool versions twice later on.</p>
<pre><code>    name: Build and deploy
    runs-on: ubuntu-latest
    env:
      GHC_VERSION: &#39;8.6.5&#39;
      CABAL_VERSION: &#39;3.0&#39;</code></pre>
<aside>
These lines define environment variables that are available in commands that we run from this job, although we don’t use them as such. Additionally, they are stored in the <code>env</code> “context”, and thus available within the workflow below. Note that the <code>env</code> context does <em>not</em> include environment variables beyond those defined within the workflow.
</aside>
</section>
<section>
<p>Finally, we give a list of steps that the job should perform. First, we call out to a github-provided action that checks out the working tree corresponding to the event that triggered the workflow.</p>
<pre><code>    steps:
      - uses: actions/checkout@master</code></pre>
<aside>
There are a number of packaged workflow components, available either from GitHub in the <a href="https://github.com/actions/">actions</a> organization, or from others via the <a href="https://github.com/marketplace?type=actions">marketplace</a>. The <code>checkout</code> action is defined in the repository <a href="https://github.com/actions/checkout">actions/checkout</a>.
</aside>
</section>
<section>
<p>Next, we call out to an action to install a Haskell toolchain. We specify versions for GHC and Cabal, referring to the variables using an adhoc expression language.</p>
<pre><code>      - uses: actions/setup-haskell@v1
        with:
          ghc-version: ${{env.GHC_VERSION}}
          cabal-version: ${{env.CABAL_VERSION}}</code></pre>
</section>
<section>
<p>Building Haskell projects tends to take too much time: A fresh build of Hakyll on the Github Actions infrastructure takes around 30 minutes. So we’ll cache the compiled dependencies. We’ll be using Cabal’s Nix-style builds here, which store artifacts in <code>$HOME/.cabal/store</code>.</p>
<p>The way caching works, we need to provide a cache key that includes full dependency version information. For simplicity, we’ll assume the existence of a Cabal version locking file <code>cabal.project.freeze</code>; see below for another approach.</p>
<pre><code>      - name: &#39;Run actions/cache@v1: cache cabal store&#39;
        uses: actions/cache@v1
        with:
          path: ~/.cabal/store
          key: cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-${{ hashFiles(&#39;cabal.project.freeze&#39;) }}
          restore-keys: |
            cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-
            cabal-store-${{ runner.OS }}-</code></pre>
When run, this action will restore any existing archive under the given key, falling back to any of the alternate keys listed under <code>restore-keys</code>. In addition, the action has a “post action”, which will save an archive at the end of a successful run.
</section>
<section>
<p>Now we’re ready to execute a couple of commands to build the Haskell project and generate the site:</p>
<pre><code>      - run: cabal update
      - run: cabal build --only-dependencies
      - run: cabal build
      - run: cabal exec site build</code></pre>
<ul>
<li><code>cabal update</code> fetches the package database from hackage. (This package database might also be cached between runs, but at ~30s I didn’t bother so far.)</li>
<li><code>cabal build --only-dependencies</code> builds the dependencies only. It’s useful to split this from the project build itself below:
<ol type="1">
<li>While getting things to work, we can disable later steps in order to get the dependency cache ready, making iterating on the later steps a lot faster.</li>
<li>We can easily distinguish between problems with the project itself and with the packaging infrastructure.</li>
</ol></li>
<li><code>cabal build</code> builds the Hakyll <code>site</code> executable itself.</li>
<li><code>cabal exec site build</code> calls this executable, generating the website.</li>
</ul>
</section>
<section>
<p>Finally, we check the commit the updated version of the site to the github pages repository, using one of a multitude of third party actions that deal with this task. This action in particular has the advantage of supporting ssh deploy keys, while most other actions appear to require a (far more powerful) personal access token to interact with a different repository.</p>
<pre><code>      - name: &#39;Run peaceiris/actions-gh-pages@v2.5.0: deploy to github pages&#39;
        uses: peaceiris/actions-gh-pages@v2.5.0
        env:
          ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }}
          PUBLISH_BRANCH: master
          PUBLISH_DIR: _site
          EXTERNAL_REPOSITORY: robx/robx.github.io
        if: github.ref == &#39;refs/heads/master&#39;</code></pre>
<p>The <code>if:</code> condition ensures that this step is only run on pushes to master.</p>
<aside>
<p>It’s nice to have the rest of the workflow execute also on other branches, to be able to debug it easily. If we didn’t want that, we might instead have limited the workflow to run only on pushes to master by filtering in the top-level <code>on:</code> field, as follows.</p>
<pre><code>on:
  push:
    branches:
      - master</code></pre>
</aside>
To configure the <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys">deploy key</a>, generate an ssh key-pair, add the public key to the github pages repository as a deploy key, and store the private key in the source repository secrets under the key <code>ACTIONS_DEPLOY_KEY</code>. The <a href="https://github.com/peaceiris/actions-gh-pages#1-add-ssh-deploy-key">README</a> of this action has detailed instructions.
</section>
<h1 id="some-extra-snippets">Some extra snippets</h1>
<h2 id="debugging">Debugging</h2>
<p>The following step is useful to have in there to aid in debugging a workflow. It stores a number of contexts to <code>env</code>, which is enough to be able to inspect them in the web interface.</p>
<pre><code>- name: Dump contexts
  env:
    CTX_GITHUB: ${{ toJson(github) }}
    CTX_STEPS: ${{ toJson(steps) }}
    CTX_ENV: ${{ toJson(env) }}
  run: true</code></pre>
<h2 id="caching-with-cabal.project.freeze">Caching with cabal.project.freeze</h2>
<p>To get reliable caching with <code>cabal</code> regardless of the existence of a freeze file, you can reorder things as follows:</p>
<pre><code>- run: cabal update
- run: &#39;[ -e cabal.project.freeze ] || cabal freeze&#39;
- name: &#39;Run actions/cache@v1: cache cabal store&#39;
  uses: actions/cache@v1
  with:
    path: ~/.cabal/store
    key: cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-${{ hashFiles(&#39;cabal.project.freeze&#39;) }}
    restore-keys: |
      cabal-store-${{ runner.OS }}-${{ env.GHC_VERSION }}-
      cabal-store-${{ runner.OS }}-
- run: cabal build --only-dependencies</code></pre>
<p>This generates an up-to-date freeze file and uses it to compute the cache key.</p>
<p>It’s necessary to get the version information into the cache key instead of just e.g. hashing the cabal file itself: Otherwise, the cache key will be constant across runs whence the cache won’t be updated, even as the cache gets outdated in relation to upstream.</p>
<aside>
As dependencies get updated, the cache will keep growing. This seems to be a general problem with dependency caching that I don’t see a good way around.
</aside>
<h1 id="github-actions-pain-points-open-ends">Github Actions pain points, open ends</h1>
<p>This works and I’m happy enough with it. Getting to this state was quite painful though, and I’m not thrilled with Github Actions in their current state. Some random thoughts:</p>
<ul>
<li><p>Storing the GHC version in <code>env</code>, and referencing this later, seems needlessly verbose. I’d prefer to be able to reference the inputs to <code>actions/setup-haskell</code> directly.</p></li>
<li><p>Generally, the variable handling is messy. I spent hours trying to get the documented HOME environment variable into the cache path, before finding out that <code>~</code> works. It turns out it <em>is</em> possible to get environment variables to the expression level, by doing the following (yikes!):</p>
<pre><code>- id: get-home
  run: |
    echo &quot;::set-output name=home::$HOME&quot;
- uses: actions/cache@v1
  with:
    path: ${{ steps.get-home.outputs.home }}/.cabal/store</code></pre></li>
<li><p>The whole thing has a very ad hoc feel to it, with lack of overall design. The language is strange – why bring Javascript-like property and index syntax into the <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions">expression syntax</a>? What’s with the weird type coercion rules? In general, it feels like a bit more distance to the Javascript sphere might have been beneficial.</p></li>
<li><p>I have doubts with respect to the trust model and third-party actions. I’m happy to trust the Github provided actions with my secrets, and I’m happy to trust e.g. <code>peaceiris/actions-gh-pages@v2.5.0</code> with my deploy key after reviewing it. But I don’t see any guarantees that it won’t be replaced by a malicious version.</p></li>
<li><p>It’s easy to make typos in YAML field names that typically won’t give obvious errors. In general, getting to a working workflow is too much trial and error, due to a combination of a confused design and inaccurate documentation. The system seems best learnt by copying and modifying existing scripts.</p></li>
<li><p>I like the option of using and providing third-party actions. However I’m not so convinced right now by the design here. I don’t see a (straightforward) way to bundle up <code>actions/setup-haskell</code> and <code>actions/cache</code> to provide a one-stop Haskell setup. And neither dropping to the Docker level nor using NodeJS (why?) are appealing.</p></li>
</ul>
<p>There are also some open ends on the Haskell side of things.</p>
<ul>
<li><p>I’m building the site with <code>stack</code> locally, instead of <code>cabal</code>. I went with <code>cabal</code> here because that’s what <code>actions/setup-haskell</code> provides, but would prefer to set this up with <code>stack</code>.</p></li>
<li><p>I’m using a forked version of Hakyll via <a href="https://github.com/robx/site-demo/blob/master/cabal.project">cabal.project</a>, and that is getting rebuilt every time. It would be nice to figure out how to cache this.</p></li>
</ul>
</article>
]]></summary>
</entry>
<entry>
    <title>Solving a word puzzle with Mercury</title>
    <link href="https://vllmrt.net/spam/solving-a-puzzle-with-mercury.html" />
    <id>https://vllmrt.net/spam/solving-a-puzzle-with-mercury.html</id>
    <published>2014-02-15T19:36:21Z</published>
    <updated>2014-02-15T19:36:21Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>February 15, 2014</time>
        
        
            <span class="orig">
                previously published at <a href="http://maybepuzzles.com/2014/02/15/an-excursion-into-logic-programming-solving-a-word-puzzle-with-mercury/">maybepuzzles</a>
            </span>
        
    </section>
    <p>I recently had the need to check a couple of puzzles that were geared towards intuitive solving, and consequently tricky to prove correct by hand. Luckily enough, Nikolai Beluhov posted an excellent <a href="https://web.archive.org/web/20140215022411/http://nbpuzzles.wordpress.com/2014/02/05/curve-data-solver-and-constructor/">Curve Data solver</a> at just the right moment, allowing me to fix one broken puzzle. For the other, I took the chance to finally play around with <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>. Prolog is likely the best-known language from this domain, but I went with <a href="http://www.mercurylang.org">Mercury</a>, which is quite close to Prolog, but adds a couple of nice things like a static type system.</p>
<p>The project was quite successful: It solved the problem and was a lot of fun. Unfortunately, the solver turned out a little too complex to fit into a blog post, largely due to the complexity of the puzzle type. Thus, I decided to break it down to a way simpler (simplistic, even) puzzle, with the option of presenting the full solver in a second post.</p>
<h3 id="a-word-placement-puzzle">A word placement puzzle</h3>
<p><strong>Rules</strong> Write the word “PUZZLE” in the grid by placing letters in some empty cells. The word may read in any of the eight horizontal, vertical or diagonal directions.</p>
<figure>
<img src="/images/wordplace.png" width="305" alt="" /><figcaption>The puzzle</figcaption>
</figure>
<p>Below, we’ll develop the solver step by step.</p>
<h2 id="building-the-solver">Building the solver</h2>
<p>A brief disclaimer before we get started: I learnt all that I know about Mercury and logic programming from this one project, so it’s quite likely that I get some things wrong. If I come across as falsely authoritative below, I apologize. Any corrections much appreciated, as well as suggestions that would make the code more idiomatic.</p>
<p>My main sources were the excellent <a href="http://www.mercurylang.org/documentation/papers/book.pdf">Mercury tutorial</a> and the <a href="http://www.mercurylang.org/information/doc-release/mercury_library/index.html">library documentation</a>. There’s also some useful examples in the source distribution, which I found a little late. To run this at home, it looks like you have to compile Mercury from source, though Linux users may be lucky? Fortunately, it turned out to be quite straightforward to build.</p>
<h3 id="the-header">The header</h3>
<p>If you paste all the code from this post into a file <code>wordplace.m</code> (or download it from <a href="https://github.com/robx/puzzles/raw/master/words/wordplace.m">github</a>), you can compile it with <code>mmc --make wordplace</code>, then run <code>./wordplace</code>.</p>
<p>We start with a standard header section, which states that all we’re exporting is the <code>main</code> predicate, and which imports a bunch of modules from the <a href="http://www.mercurylang.org/information/doc-release/mercury_library/index.html">standard library</a>.</p>
<pre><code>:- module wordplace.

:- interface.

:- import_module io.

:- pred main(io::di, io::uo) is det.

:- implementation.

:- import_module char.
:- import_module int.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module solutions.
:- import_module string.</code></pre>
<h3 id="types-and-data">Types and data</h3>
<p>Next, we define some types in order to be able to express the puzzle. We’re working with a two-dimensional square grid of characters; the puzzle is specified by the size of the grid, by the hints (characters at points), and the word we’re trying to place.</p>
<p>There’s no particular reason I went with named fields for <code>size</code> and a plain pair of integers for <code>point</code> here. They’re mostly the same, for our purposes at least. (There’s also an explicit <code>pair</code> type in the standard library (<a href="http://www.mercurylang.org/information/doc-release/mercury_library/pair.html">pair</a>), don’t ask me why.) For <code>word</code>, we might have chosen <code>string</code> instead, but lists of characters seem easier to work with.</p>
<p><code>size</code> and <code>puzzle</code> are both new types, with the difference that the fields are named for <code>size</code>, the others are just new type names. There’s no need for the the left “<code>puzzle</code>” (the type name) to agree with the right “<code>puzzle</code>” (the data constructor).</p>
<pre><code>:- type hint == {point, char}.
:- type word == list(char).
:- type size ---&gt; size(width :: int, height :: int).
:- type puzzle ---&gt; puzzle(size, word, list(hint)).</code></pre>
<p>Our sample puzzle is then simply a constant function with no arguments, with value <code>P</code> of type <code>puzzle</code> constructed from its parts.</p>
<pre><code>:- func sample = puzzle.
sample = P :-
    S = size(7, 7),
    W = string.to_char_list(&quot;PUZZLE&quot;),
    Hs = [ {{1, 6}, &#39;P&#39;}, {{2, 6}, &#39;P&#39;}, {{3, 6}, &#39;U&#39;}
         , {{4, 5}, &#39;U&#39;}, {{6, 5}, &#39;P&#39;}
         , {{1, 4}, &#39;E&#39;}, {{2, 4}, &#39;Z&#39;}, {{4, 4}, &#39;E&#39;}, {{6, 4}, &#39;Z&#39;}
         , {{0, 3}, &#39;L&#39;}, {{3, 3}, &#39;Z&#39;}, {{6, 3}, &#39;L&#39;}
         , {{0, 2}, &#39;P&#39;}, {{2, 2}, &#39;U&#39;}, {{4, 2}, &#39;Z&#39;}, {{5, 2}, &#39;E&#39;}
         , {{0, 1}, &#39;U&#39;}, {{2, 1}, &#39;Z&#39;}
         , {{3, 0}, &#39;L&#39;}, {{4, 0}, &#39;U&#39;}, {{5, 0}, &#39;P&#39;}
         ],
    P = puzzle(S, W, Hs).</code></pre>
<p>We’ll also need some way to represent the character grid. Here, we’ll go with a <a href="http://www.mercurylang.org/information/doc-release/mercury_library/map.html">map</a> of <code>point</code> to <code>char</code>. A cell is empty if the corresponding point is not in the map, otherwise the character in that cell is the mapped value. We also include the size of the grid, and agree to index the cells with pairs <code>{0..width-1,0..height-1}</code>.</p>
<pre><code>:- type grid ---&gt; grid(size :: size, map :: map(point, char)).</code></pre>
<h3 id="an-outline-and-main">An outline, and <code>main</code></h3>
<p>Now we’re ready to declare the core of our solver:</p>
<pre><code>:- pred solve(puzzle::in, grid::out) is nondet.</code></pre>
<p><code>solve(P, G)</code> states that the grid <code>G</code> is a solution of the puzzle <code>P</code>. Futhermore, we’re saying that we’ll give a definition of <code>solve</code> that allows determining such <code>G</code> given <code>P</code> (the <code>in</code> and <code>out</code> modes), and that for a given <code>P</code>, there may be 0 to many <code>G</code> (<code>nondet</code>).</p>
<p>The fun part will be implementing <code>solve</code>, but first let’s wrap it in a proper program. Our aim is simply to find and print all solutions to the puzzle. Printing is handled by a deterministic predicate <code>print_grids</code> (implementation deferred), which takes a list of grids, and transforms the state of the world (which has type <code>io</code>). Compare to the declaration of the <code>main</code> predicate in the header.</p>
<pre><code>:- pred print_grids(list(grid)::in, io::di, io::uo) is det.</code></pre>
<p>The <a href="http://www.mercurylang.org/information/doc-release/mercury_library/solutions.html">solutions</a> module provides some tools for getting at all results of a predicate. <code>solutions.solutions</code> in particular returns all outputs of a one-parameter predicate. Now we can define <code>main</code>:</p>
<pre><code>main(IO_in, IO_out) :-
    solutions(pred(G::out) is nondet :- solve(sample, G),
              Gs),
    print_grids(Gs, IO_in, IO_out).</code></pre>
<p>The first argument to <code>solutions</code> is an anonymous predicate that’s the partial application of <code>solve</code> to our sample puzzle.</p>
<p>This is probably a good point to think about how to think about that definition of <code>main</code>: We’re not saying to first compute the solutions, afterwards print the grids. Instead, we’re saying that the predicate <code>main</code> is the conjunction of the two statements, the comma should be read as “and”. We leave it to the compiler to actually do something with that definition.</p>
<p><code>main</code> transforms the state of the world from <code>IO_in</code> to <code>IO_out</code> if and only if <code>Gs</code> is the list of solutions to our puzzle, and printing the grids <code>Gs</code> transforms the world from <code>IO_in</code> to <code>IO_out</code>. Now running the program means finding out what <code>main</code> does to the state of the world, which means finding out what <code>print_grids</code> does, which depends on <code>Gs</code>. So <code>solutions</code> needs to be “called” first, before <code>print_grids</code> can be “called” on the results.</p>
<p>In particular, the order of the statements doesn’t matter, we might as well have placed that <code>print_grids</code> statement at the beginning. That said, it’s helpful to order definitions in a way that they can be evaluated top-to-bottom.</p>
<h3 id="solving-the-puzzle">Solving the puzzle</h3>
<p>We’ll let the grid do most of the work. First, let’s set it up properly, by setting the size and initializing the underlying map.</p>
<pre><code>:- pred init_grid(size::in, grid::out) is det.
init_grid(S, G) :-
    map.init(M),
    G = grid(S, M).</code></pre>
<p>Some bounds checking will be useful. Note that the following two predicates are in a sense the same: They both state that the point <code>P</code> is within the bounds given by <code>S</code>. But as defined below, <code>in_bounds</code> tests this property, while <code>nondet_in_bounds</code> generates points within the given bounds.</p>
<pre><code>:- pred in_bounds(size::in, point::in) is semidet.
in_bounds(S, {X, Y}) :-
    X &gt;= 0,
    Y &gt;= 0,
    X &lt; S^width,
    Y &lt; S^height.

:- pred nondet_in_bounds(size::in, point::out) is nondet.
nondet_in_bounds(S, {X, Y}) :-
    size(W, H) = S,
    int.nondet_int_in_range(0, W - 1, X),
    int.nondet_int_in_range(0, H - 1, Y).</code></pre>
<p>With this, we’re ready to define the fundamental grid operation, placing a character <code>C</code> at a point <code>P</code> in a grid <code>G</code>. This is semi-deterministic: If the position is out of bounds, or if there’s already a different character at that location, the character can’t be placed. Otherwise, the resulting grid is unique. In other words, there’s at most one result.</p>
<pre><code>:- pred place_char(point::in, char::in, grid::in, grid::out) is semidet.
place_char(P, C, Gin, Gout) :-
    grid(S, M) = Gin,
    in_bounds(S, P),
    map.search_insert(P, C, OldC, M, M1),
    (
        OldC = no
    ;
        OldC = yes(C)
    ),
    Gout = grid(S, M1).</code></pre>
<p>Line by line, we first deconstruct the input grid, then check that the point is in bounds. We rely on <a href="http://www.mercurylang.org/information/doc-release/mercury_library/map.html">map.search_insert</a> to handle the conditional map update. Its input parameters are the point <code>P</code>, the character <code>C</code>, and the original map <code>M</code>. Its output consists of <code>OldC</code> which has type <code>maybe(char)</code>, and the modified map <code>M1</code>. A <code>maybe(char)</code> is either nothing (<code>no</code>) or some character (<code>yes('a')</code>). Now <code>search_insert</code> does one of two things: If the map already contains <code>P</code> with value <code>D</code>, the map isn’t changed, and <code>OldC</code> is set to <code>yes(D)</code>. Otherwise, the element is inserted, and <code>OldC</code> is set to <code>no</code>.</p>
<p>Following the optional insert we see a disjunction: We say it’s fine if <code>OldC</code> is <code>no</code> (i.e., the cell was previously empty), or if <code>OldC</code> is <code>yes(C)</code> (i.e., the cell was previously occupied, but with the character we’re trying to place. The case that we’re deliberately omitting is <code>yes(D)</code> for some other character <code>D</code>: that’s a real collision.</p>
<p>Finally, we put <code>S</code> and the modified map <code>M1</code> back together to yield the result grid.</p>
<p>Building on this, we can define a couple of predicates to place more than one character at a time. First, a list of located characters (we could use <code>foldl</code> here instead of explicit recursion).</p>
<pre><code>:- pred place_chars(list({point, char}):: in, grid::in, grid::out) is semidet.
place_chars([], Gin, Gout) :-
    Gout = Gin.
place_chars([{P, C}|Xs], Gin, Gout) :-
    place_char(P, C, Gin, G1),
    place_chars(Xs, G1, Gout).</code></pre>
<p>Next, placing a <code>word</code> in a specified direction starting at a given point.</p>
<pre><code>:- type dir == {int, int}.

:- func move(dir, point) = point.
move({DX, DY}, {PX, PY}) = {PX + DX, PY + DY}.

:- pred place_word(point::in, dir::in, word::in,
                   grid::in, grid::out) is semidet.
place_word(_, _, [], Gin, Gout) :-
    Gin = Gout.
place_word(P, D, [C|Cs], Gin, Gout) :-
    place_char(P, C, Gin, G),
    P1 = move(D, P),
    place_word(P1, D, Cs, G, Gout).</code></pre>
<p>Or placing a <code>word</code> in an arbitrary direction at an arbitrary point:</p>
<pre><code>:- func dirs = list(dir).
dirs = [ {-1,-1}, {-1, 0}, {-1, 1}, { 0, 1}
       , { 1, 1}, { 1, 0}, { 1,-1}, { 0,-1}
       ].

:- pred place_word_any(word::in, grid::in, grid::out) is nondet.
place_word_any(W, Gin, Gout) :-
    grid(S, _) = Gin,
    nondet_in_bounds(S, P),
    list.member(D, dirs),
    place_word(P, D, W, Gin, Gout).</code></pre>
<p>Puzzle solved:</p>
<pre><code>solve(Pz, Gout) :-
    Pz = puzzle(S, W, Hs),
    init_grid(S, G0),
    place_chars(Hs, G0, G1),
    place_word_any(W, G1, Gout).</code></pre>
<h3 id="printing-the-solutions">Printing the solutions</h3>
<p>To finish off the program, we still need to implement <code>print_grids</code>. That’s below. <del>with some code that feels a little suboptimal. I’m sure it’s not necessary to define ranges of integers, and there must be a more elegant way to convert from a semi-deterministic predicate to a maybe type than going through lists. But it works.</del> <strong>Edit</strong> Improved version, thanks to Paul Bone.</p>
<p>By the way, the <code>!IO</code> is just magic syntax for stringing through a list of modifications, we might have used <code>!G</code> at some points above where we did the <code>Gin</code>, <code>G1</code>, <code>Gout</code> dance.</p>
<pre><code>:- func int_range(int) = list(int).
int_range(N) = (if N =&lt; 0 then [] else [N - 1|int_range(N - 1)]).

:- pred char_at(grid::in, point::in, char::out) is semidet.
char_at(G, P, C) :-
    C = map.search(G^map, P).

:- func show_char(grid, point) = char.
show_char(G, P) = C :-
    ( if char_at(G, P, CPrime) then
        C = CPrime
    else
        C = (&#39;.&#39;)
    ).

:- func show_line(grid, int) = string.
show_line(G, Y) =
    string.from_char_list(
        map(func(X) = show_char(G, {X, Y}),
            list.reverse(int_range(G^size^width)))
    ).

:- func show(grid) = list(string).
show(G) = map(func(Y) = show_line(G, Y), int_range(G^size^height)).

:- pred write_line(string::in, io::di, io::uo) is det.
write_line(L, !IO) :- io.format(&quot;%s\n&quot;, [s(L)], !IO).

print_grids([], !IO).
print_grids([G|Gs], !IO) :-
    foldl(write_line, show(G), !IO),
    print_grids(Gs, !IO).</code></pre>
</article>
]]></summary>
</entry>
<entry>
    <title>Drawing puzzles with TikZ</title>
    <link href="https://vllmrt.net/spam/drawing-puzzles-with-tikz.html" />
    <id>https://vllmrt.net/spam/drawing-puzzles-with-tikz.html</id>
    <published>2014-02-05T19:26:48Z</published>
    <updated>2014-02-05T19:26:48Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        <time>February  5, 2014</time>
        
        
            <span class="orig">
                previously published at <a href="https://maybepuzzles.com/2014/02/05/drawing-puzzles-with-tikz/">maybepuzzles</a>
            </span>
        
    </section>
    <p>There seems to be a lack of information out there when it comes to rendering puzzles. The most obvious approach is probably to use a vector graphics program such as <a href="http://inkscape.org">Inkscape</a>, but people also use spreadsheet software or write Postscript directly. I’ve recently started using the Haskell <a href="http://projects.haskell.org/diagrams/">Diagrams</a> framework (more on that in a future post), but for today, I want to share how to render pretty puzzles using TikZ via LaTeX.</p>
<p>Simplifying things a bit, <a href="http://en.wikipedia.org/wiki/PGF/TikZ">TikZ</a> is a vector graphics package for the <a href="http://en.wikipedia.org/wiki/LaTeX">LaTeX</a> document preparation system. If you want to follow along at home, install some TeX system, typically via your OS’ packaging system or from <a href="https://www.tug.org/texlive/">TeX Live</a>. We’ll be writing a text file <code>puzzle.tex</code>; running <code>pdflatex puzzle.tex</code> will yield <code>puzzle.pdf</code> if nothing goes wrong. Or use <a href="https://www.tug.org/texworks/">TeXworks</a>.</p>
<p>As an example, we’ll draw a small Slalomrundweg, see the <a href="http://www.logic-masters.de/Raetselportal/Raetsel/zeigen.php?id=00016Q">Rätselportal</a> for the rules. Here’s what it will look like:</p>
<figure>
<img src="/images/slalomrundweg.png" width="380" alt="" /><figcaption>Slalomrundweg</figcaption>
</figure>
<p>We’ll start with some boilerplate; it’s a good idea to keep the code below in a file <code>template.tex</code>:</p>
<pre><code>\documentclass{article}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage[tightpage,active]{preview}
\PreviewEnvironment{tikzpicture}

\begin{document}
\begin{tikzpicture}[scale=0.8]

% insert puzzle here

\end{tikzpicture}
\end{document}</code></pre>
<p>This sets up a basic LaTex document that consists of a single TikZ picture. We tell LaTeX to load TikZ, including the <code>arrows</code> library, and to produce an output file that contains just the <code>tikzpicture</code> we’re going to fill in below. Cropping the document to that picture is what the mysterious <code>preview</code> stuff is for. One thing to note is the option <code>scale</code> to the <code>tikzpicture</code> environment: The default unit is 1cm, so this makes our grid cells have size 8mm.</p>
<p>Let’s put in a grid:</p>
<pre><code>\draw[thin, black!50] (0,0) grid (6,6);
\draw[very thick] (0,0) rectangle (6,6);</code></pre>
<p>Pretty easy, right? Paste this inside the <code>tikzpicture</code> environment and render it, and you should see an empty grid. The edges might not be very nice because of how <code>preview</code> crops the document to the picture; we could fix this by setting a <code>PreviewBorder</code>, but instead we’ll just enlarge the picture size. This will also make the image stay centered once we add the arrows.</p>
<pre><code>\path (-1,-1) rectangle (7,7);</code></pre>
<p><code>\path</code> is like <code>\draw</code>, except that it doesn’t use a pen. Next, we’ll add the clues. To just put the letter <code>A</code> at the point (2,3), we’d use <code>\node at (2,3) {A};</code>, but we need a little more than that for our circled clues.</p>
<pre><code>\tikzstyle{clue} = [
    circle,
    draw,
    fill=white,
    inner sep=2pt,
    font=\sffamily\large
]

\foreach \x/\y/\c in {1/1/1, 1/5/1, 5/1/3, 5/5/4, 3/3/1}
    \node[clue] at (\x,\y) {\c};</code></pre>
<p>First we define the style of our clue nodes. This isn’t strictly necessary, it just means that when we write <code>\node[clue]</code>, the <code>clue</code> part is replaced by all the things in the earlier list. Those are:</p>
<dl>
<dt><code>circle</code></dt>
<dd><p>the outline of the node is a circle</p>
</dd>
<dt><code>draw</code></dt>
<dd><p>we want the outline to be drawn</p>
</dd>
<dt><code>fill=white</code></dt>
<dd><p>we fill the background in white, to cover the grid lines</p>
</dd>
<dt><code>inner sep=2pt</code></dt>
<dd><p>a margin between the text and the circle (the node is sized to accomodate the text, which might not really be what we want here…)</p>
</dd>
<dt><code>font=\sffamily\large</code></dt>
<dd><p>choose the text font and size</p>
</dd>
</dl>
<p>Then, we use <code>\foreach</code> to place the clues at the given coordinates.</p>
<p>Finally, let’s add the arrows for the solution code. There’s some tricky stuff here that’s required to get them to look just right.</p>
<pre><code>\tikzstyle{arr} = [
    -triangle 90,
    line width=0.4mm,
    postaction={draw, line width=0.1cm, shorten &gt;=0.1cm, -}
]
\draw[arr] (-0.7,3) -- (-0.2,3);
\draw[arr] (3,6.7) -- (3,6.2);</code></pre>
<p>That’s it! As a bonus, and at the risk of spoiling the puzzle, add the following. Best between drawing the grid and drawing the clues.</p>
<pre><code>\draw[ultra thick, black!70]
    (3,5) -- (1,3) -- (3,1) -- (5,3)
    (1,1) -- (2,2)    (1,5) -- (2,4)
    (4,0) -- (6,2)    (5,1) -- (6,0)
    (3,3) -- (6,6)    (4,6) -- (6,4);
\draw[ultra thick, red!70]
    (1,0) -- (2,1) -- (3,0) -- (6,3)
          -- (5,4) -- (3,2) -- (2,3)
          -- (4,5) -- (3,6) -- (2,5)
          -- (1,6) -- (0,5) -- (1,4)
          -- (0,3) -- (1,2) -- (0,1) -- (1,0);</code></pre>
</article>
]]></summary>
</entry>

</feed>
